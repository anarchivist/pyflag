diff -Naur ethereal-0.9.16/epan/except.c ethereal-0.9.16_new/epan/except.c
--- ethereal-0.9.16/epan/except.c	2002-08-29 10:40:07.000000000 +1000
+++ ethereal-0.9.16_new/epan/except.c	2003-11-26 19:27:45.000000000 +1100
@@ -348,6 +348,7 @@
 
 void except_free(void *ptr)
 {
+  if(ptr)
     get_dealloc()(ptr);
 }
 
diff -Naur ethereal-0.9.16/epan/proto.c ethereal-0.9.16_new/epan/proto.c
--- ethereal-0.9.16/epan/proto.c	2003-11-03 04:15:23.000000000 +1100
+++ ethereal-0.9.16_new/epan/proto.c	2003-11-26 19:27:45.000000000 +1100
@@ -43,6 +43,7 @@
 #include "proto.h"
 #include "int-64bit.h"
 #include "epan_dissect.h"
+#include "../sql.h"
 
 #define cVALS(x) (const value_string*)(x)
 
@@ -1649,6 +1650,7 @@
 		case FT_INT16:
 		case FT_INT24:
 		case FT_INT32:
+	                 case FT_FRAMENUM:
 			pi = proto_tree_add_pi(tree, hfindex, tvb, start, &length,
 					&new_fi);
 			proto_tree_set_int(new_fi, value);
@@ -2079,6 +2081,30 @@
 	return g_strcasecmp(p1->short_name, p2->short_name);
 }
 
+/* Register the protocol as one that will be output in SQL */
+void proto_register_sql_protocol(int id) 
+{
+  int len = gpa_hfinfo->len;
+  int i;
+  
+  header_field_info *hfinfo=proto_registrar_get_nth(id);
+  if(hfinfo) hfinfo->sql=2;
+  
+  for (i = 0; i < len ; i++) {
+    hfinfo = proto_registrar_get_nth(i);
+    if(hfinfo->sql == 2) {
+      int j;
+
+      for(j=0; j< MAX_KB_PTR; j++) {
+	if(kb_ptr[j] && !strcmp(hfinfo->abbrev,kb_ptr[j])) {
+	  //printf("found protocol %s\n",hfinfo->abbrev);
+	  kb_ptr[j]=hfinfo->abbrev;
+	};
+      };
+    };
+  };
+};
+
 int
 proto_register_protocol(char *name, char *short_name, char *filter_name)
 {
@@ -2096,6 +2122,8 @@
 	g_assert(g_list_find_custom(protocols, short_name, proto_match_short_name) == NULL);
 	g_assert(g_list_find_custom(protocols, filter_name, proto_match_filter_name) == NULL);
 
+//	printf("Registered protocol %s or %s -> %s\n",name,short_name,filter_name);
+
 	/* Add this protocol to the list of known protocols; the list
 	   is sorted by protocol short name. */
 	protocol = g_malloc(sizeof (protocol_t));
@@ -2453,6 +2481,140 @@
 		**ptr = num_tree_types;
 }
 
+
+/* Fills in the SQL labels, based in proto_item_fill_label */
+void
+proto_item_fill_sql_label (field_info *fi, gchar *label_str)
+{
+	header_field_info		*hfinfo = fi->hfinfo;
+
+	guint8				*bytes;
+	guint32				integer;
+ 
+	switch(hfinfo->type) {
+		case FT_NONE:
+		case FT_PROTOCOL:
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s", hfinfo->name);
+			break;
+
+		case FT_BOOLEAN:
+			fill_label_boolean(fi, label_str);
+			break;
+
+		case FT_BYTES:
+		case FT_UINT_BYTES:
+			bytes = fvalue_get(fi->value);
+			if (bytes) {
+				snprintf(label_str, ITEM_LABEL_LENGTH,
+					"%s: %s", hfinfo->name,
+					 bytes_to_str(bytes, fvalue_length(fi->value)));
+			}
+			else {
+				snprintf(label_str, ITEM_LABEL_LENGTH,
+					"%s: <MISSING>", hfinfo->name);
+			}
+			break;
+
+		/* Four types of integers to take care of:
+		 * 	Bitfield, with val_string
+		 * 	Bitfield, w/o val_string
+		 * 	Non-bitfield, with val_string
+		 * 	Non-bitfield, w/o val_string
+		 */
+		case FT_UINT8:
+		case FT_UINT16:
+		case FT_UINT24:
+		case FT_UINT32:	
+	                 case FT_FRAMENUM:
+			snprintf(label_str, ITEM_LABEL_LENGTH,  "%lu",(long unsigned int) fvalue_get_integer(fi->value));
+			break;
+
+		case FT_UINT64:
+			fill_label_uint64(fi, label_str);
+			break;
+
+		case FT_INT8:
+		case FT_INT16:
+		case FT_INT24:
+		case FT_INT32:
+			g_assert(!hfinfo->bitmask);
+			snprintf(label_str, ITEM_LABEL_LENGTH,  "%d",fvalue_get_integer(fi->value));
+			break;
+
+		case FT_INT64:
+			fill_label_int64(fi, label_str);
+			break;
+
+		case FT_FLOAT:
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s: %.9g", hfinfo->name, fvalue_get_floating(fi->value));
+			break;
+
+		case FT_DOUBLE:
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s: %.14g", hfinfo->name, fvalue_get_floating(fi->value));
+			break;
+
+		case FT_ABSOLUTE_TIME:
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s",abs_time_to_sql(fvalue_get(fi->value)));
+			break;
+
+		case FT_RELATIVE_TIME:
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s", rel_time_to_secs_str(fvalue_get(fi->value)));
+			break;
+
+		case FT_IPXNET:
+			integer = fvalue_get_integer(fi->value);
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s: 0x%08X (%s)", hfinfo->name,
+				integer, get_ipxnet_name(integer));
+			break;
+
+		case FT_ETHER:
+			bytes = fvalue_get(fi->value);
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s", ether_to_str(bytes));
+			break;
+
+		case FT_IPv4:
+/*
+			ipv4 = fvalue_get(fi->value);
+			n_addr = ipv4_get_net_order_addr(ipv4);
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s", ip_to_str((guint8*)&n_addr));
+*/
+			snprintf(label_str,ITEM_LABEL_LENGTH,"%lu",ipv4_get_host_order_addr(fvalue_get(fi->value)));
+			break;
+
+		case FT_IPv6:
+			bytes = fvalue_get(fi->value);
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s: %s (%s)", hfinfo->name,
+				get_hostname6((struct e_in6_addr *)bytes),
+				ip6_to_str((struct e_in6_addr*)bytes));
+			break;
+
+		case FT_STRING:
+		case FT_STRINGZ:
+		case FT_UINT_STRING:
+			bytes = fvalue_get(fi->value);
+			snprintf(label_str, ITEM_LABEL_LENGTH,
+				"%s", 
+				format_text(bytes, strlen(bytes)));
+			break;
+
+		default:
+			g_error("hfinfo->type %d (%s) not handled\n",
+					hfinfo->type,
+					ftype_name(hfinfo->type));
+			g_assert_not_reached();
+			break;
+	}
+}
+
 void
 proto_item_fill_label(field_info *fi, gchar *label_str)
 {
@@ -3358,6 +3520,173 @@
 	}
 }
 
+/* Dumps SQL create statements to stdout, based on proto_registrar_dump_fields */
+GString *create_sql=NULL;
+GString *enumerated_sql=NULL;
+
+void
+proto_registrar_dump_sql(int creation)
+{
+	header_field_info	*hfinfo, *parent_hfinfo;
+	int			i, len;
+	const char 		*enum_name;
+	
+
+	if(creation) {
+		printf("create table data (key_id int, length int, data blob,key key_id(key_id));\ncreate table enum (name varchar(50),value int,string varchar(50));\n");
+
+		len = gpa_hfinfo->len;
+		for (i = 0; i < len ; i++) {
+			hfinfo = proto_registrar_get_nth(i);
+			if (strlen(hfinfo->name) == 0 || strlen(hfinfo->abbrev) == 0)
+				continue; 
+ 
+			/* format for protocols */
+			if (proto_registrar_is_protocol(i)) {
+				if(hfinfo->sql==2) {
+					if(create_sql) {
+						printf("%skey_id INT );\n",create_sql->str);
+						g_string_free(create_sql,1);
+						create_sql=g_string_new("");
+					} else {
+						create_sql=g_string_new("");
+					};
+	
+					if(enumerated_sql) {
+						printf("%s",enumerated_sql->str);
+						g_string_free(enumerated_sql,1);
+						enumerated_sql=NULL;
+					};
+
+					create_sql=g_string_new("");
+					g_string_sprintfa(create_sql,"insert into meta set property=\"tcpdump_table\", value= \"%s\";\nCreate table `%s` (\n",hfinfo->abbrev,hfinfo->abbrev);
+				};
+			}
+			/* format for header fields */
+			else {
+				char *type;
+				if (hfinfo->same_name_prev != NULL)
+					continue;
+
+				parent_hfinfo = proto_registrar_get_nth(hfinfo->parent);
+				g_assert(parent_hfinfo);
+
+				enum_name = ftype_name(hfinfo->type);
+				switch(hfinfo->type) {
+				case FT_UINT8:
+					type="TINYINT UNSIGNED";
+					break;
+				case FT_UINT16:
+					type="SMALLINT UNSIGNED";
+					break;
+				case FT_UINT24:
+					type="MEDIUMINT UNSIGNED";
+					break;
+				case FT_UINT32:
+					type="INT UNSIGNED";
+					break;
+				case FT_UINT64:
+					type="BIGINT UNSIGNED";
+					break;
+				case FT_INT8:
+					type="TINYINT";
+					break;
+				case FT_INT16:
+					type="SMALLINT";
+					break;
+				case FT_INT24:
+					type="MEDIUMINT";
+					break;
+				case FT_INT32:
+					type="INT";
+					break;
+				case FT_INT64:
+					type="BIGINT";
+					break;
+				case FT_FLOAT:
+					type="FLOAT";
+					break;
+				case FT_DOUBLE:
+					type="DOUBLE";
+					break;
+				case FT_STRING:
+				case FT_STRINGZ:
+				case FT_UINT_STRING:
+					type="TEXT";
+					break;
+				case FT_IPv4:
+					type="BIGINT";
+					break;
+				case FT_BYTES:
+					type="BLOB";
+					break;
+				case FT_ETHER:
+					type="VARCHAR(50)";
+					break;
+				case FT_BOOLEAN:
+					type="BOOL";
+					break;
+				case FT_ABSOLUTE_TIME:
+					type="DATETIME";
+					break;
+				default:
+					type="TEXT";
+				};
+	
+				//Enumerated types can be dumped off here
+				if(hfinfo->sql==2) {
+					char *new_name = strdup(hfinfo->abbrev);
+					char *name=new_name+strlen(new_name);
+					value_string *cur;
+					int i;
+	
+					/* we replace . with _ in the column names   */
+					while(name > new_name) {
+						if(*name=='.') *name='_';
+						name--;
+					};
+	
+					//Enumerated types can be dumped off here
+					if(hfinfo->strings) {
+						if(!enumerated_sql) enumerated_sql=g_string_new("");
+						cur= (value_string*) hfinfo->strings;
+						for(i=1; cur->strptr; cur = &(((value_string*) hfinfo->strings)[i++])) {
+							g_string_sprintfa(enumerated_sql,"insert into enum set name = \"%s\", value=\"%d\", string = \"%s\";\n",new_name,cur->value,cur->strptr);
+						};
+					};
+					
+					
+	//				printf("Field \t%s\t%s\t%s\t%s\t%s\n", hfinfo->name, hfinfo->abbrev,enum_name,parent_hfinfo->abbrev, hfinfo->blurb);
+					g_string_sprintfa(create_sql,"/* %s : %s */\n%s %s,\n", hfinfo->name,hfinfo->blurb,new_name,type);
+					free(new_name);
+				}; 
+			}
+		}
+	
+		if(create_sql) {
+			printf("%skey_id INT );\n",create_sql->str);
+			g_string_free(create_sql,1);
+		}
+	} else {
+	printf("drop table dns_data; \ndrop table data;\n drop table enum;\n");
+
+		len = gpa_hfinfo->len;
+		for (i = 0; i < len ; i++) {
+			hfinfo = proto_registrar_get_nth(i);
+			if (strlen(hfinfo->name) == 0 || strlen(hfinfo->abbrev) == 0)
+				continue;
+ 
+			/* format for protocols */
+			if (proto_registrar_is_protocol(i)) {
+				if(hfinfo->sql==2) {
+					printf("drop table `%s`;\n",hfinfo->abbrev);
+				};
+			};
+
+		};
+	};
+}
+
 static char*
 hfinfo_numeric_format(header_field_info *hfinfo)
 {
diff -Naur ethereal-0.9.16/epan/proto.h ethereal-0.9.16_new/epan/proto.h
--- ethereal-0.9.16/epan/proto.h	2003-11-03 04:15:23.000000000 +1100
+++ ethereal-0.9.16_new/epan/proto.h	2003-11-26 19:27:45.000000000 +1100
@@ -83,6 +83,7 @@
 	int				bitshift;	/* bits to shift */
 	header_field_info		*same_name_next; /* Link to next hfinfo with same abbrev*/
 	header_field_info		*same_name_prev; /* Link to previous hfinfo with same abbrev*/
+	char                                                                                        sql;   /* Do we include this one in the SQL dumps */
 };
 
 /*
@@ -90,7 +91,8 @@
  * "header_field_info"; if new fields are added or removed, it should
  * be changed as necessary.
  */
-#define HFILL 0, 0, 0, NULL, NULL
+#define HFILL 0, 0, 0, NULL, NULL,0
+#define SQLFILL 0, 0, 0, NULL, NULL,2
 
 /* Used when registering many fields at once */
 typedef struct hf_register_info {
diff -Naur ethereal-0.9.16/epan/to_str.c ethereal-0.9.16_new/epan/to_str.c
--- ethereal-0.9.16/epan/to_str.c	2003-10-09 08:44:36.000000000 +1000
+++ ethereal-0.9.16_new/epan/to_str.c	2003-11-26 19:27:45.000000000 +1100
@@ -435,6 +435,38 @@
 	"Dec"
 };
 
+/* For SQL engine */
+gchar *
+abs_time_to_sql(nstime_t *abs_time)
+{
+        struct tm *tmp;
+        static gchar *cur;
+        static char str[3][3+1+2+2+4+1+2+1+2+1+2+1+6+1 + 5 /* extra */];
+
+        if (cur == &str[0][0]) {
+                cur = &str[1][0];
+        } else if (cur == &str[1][0]) {
+                cur = &str[2][0];
+        } else {
+                cur = &str[0][0];
+        }
+
+        tmp = localtime(&abs_time->secs);
+        if (tmp) {
+          sprintf(cur, "%d/%d/%d %02d:%02d:%02d",
+                  tmp->tm_year + 1900,
+                  tmp->tm_mon,
+                  tmp->tm_mday,
+                  tmp->tm_hour,
+                  tmp->tm_min,
+                  tmp->tm_sec
+                  );
+        } else {
+          strncpy(cur, "Not representable", sizeof(str[0]));
+        }
+        return cur;
+};
+
 gchar *
 abs_time_to_str(nstime_t *abs_time)
 {
diff -Naur ethereal-0.9.16/epan/to_str.h ethereal-0.9.16_new/epan/to_str.h
--- ethereal-0.9.16/epan/to_str.h	2003-08-28 09:01:21.000000000 +1000
+++ ethereal-0.9.16_new/epan/to_str.h	2003-11-26 19:27:45.000000000 +1100
@@ -62,6 +62,7 @@
 extern gchar*	time_secs_to_str(guint32);
 extern gchar*	time_msecs_to_str(guint32);
 extern gchar*	abs_time_to_str(nstime_t*);
+extern gchar*	abs_time_to_sql(nstime_t*);
 extern gchar*	abs_time_secs_to_str(time_t);
 extern void	display_signed_time(gchar *, int, gint32, gint32, time_res_t);
 extern gchar*	rel_time_to_str(nstime_t*);
diff -Naur ethereal-0.9.16/gtk/main.c ethereal-0.9.16_new/gtk/main.c
--- ethereal-0.9.16/gtk/main.c	2003-11-03 06:31:20.000000000 +1100
+++ ethereal-0.9.16_new/gtk/main.c	2003-11-26 19:27:45.000000000 +1100
@@ -1683,9 +1683,13 @@
     else {
       if (strcmp(argv[2], "fields") == 0)
         proto_registrar_dump_fields();
-      else if (strcmp(argv[2], "protocols") == 0)
+      else if (strcmp(argv[2], "protocols") == 0) {
         proto_registrar_dump_protocols();
-      else {
+      } else if(!strcmp(argv[2],"sql")) {
+	      proto_registrar_dump_sql(1);
+      } else if(!strcmp(argv[2],"drop")) {
+	      proto_registrar_dump_sql(0);
+      } else {
         fprintf(stderr, "ethereal: Invalid \"%s\" option for -G flag\n",
                 argv[2]);
         exit(1);
diff -Naur ethereal-0.9.16/ipproto.c ethereal-0.9.16_new/ipproto.c
--- ethereal-0.9.16/ipproto.c	2003-11-03 09:12:35.000000000 +1100
+++ ethereal-0.9.16_new/ipproto.c	2003-11-26 19:27:45.000000000 +1100
@@ -32,7 +32,6 @@
 
 #include <glib.h>
 
-#include "ipproto.h"
 #include <epan/packet.h>
 #include <epan/resolv.h>
 #include "packet-ip.h"
@@ -41,145 +40,7 @@
 # include "snprintf.h"
 #endif
 
-static const value_string ipproto_val[] = {
-#if 0
-    { IP_PROTO_IP,	"IPv4" },
-#endif
-    { IP_PROTO_HOPOPTS,	"IPv6 hop-by-hop option" },
-    { IP_PROTO_ICMP,	"ICMP" },
-    { IP_PROTO_IGMP,	"IGMP" },
-    { IP_PROTO_GGP,	"GGP" },
-    { IP_PROTO_IPIP,	"IPIP" },
-#if 0
-    { IP_PROTO_IPV4,	"IPv4" },
-#endif
-    { IP_PROTO_STREAM,  "Stream" },
-    { IP_PROTO_TCP,	"TCP" },
-    { IP_PROTO_CBT,     "CBT" },
-    { IP_PROTO_EGP,	"EGP" },
-    { IP_PROTO_IGP,	"IGRP" },
-    { IP_PROTO_BBN_RCC, "BBN RCC" },
-    { IP_PROTO_NVPII,   "Network Voice" },
-    { IP_PROTO_PUP,	"PUP" },
-    { IP_PROTO_ARGUS,   "ARGUS" },
-    { IP_PROTO_EMCON,   "EMCON" },
-    { IP_PROTO_XNET,    "XNET" },
-    { IP_PROTO_CHAOS,   "CHAOS" },
-    { IP_PROTO_UDP,	"UDP" },
-    { IP_PROTO_MUX,     "Multiplex" },
-    { IP_PROTO_DCNMEAS, "DCN Measurement" },
-    { IP_PROTO_HMP,     "Host Monitoring" },
-    { IP_PROTO_PRM,     "Packet radio" },
-    { IP_PROTO_IDP,	"IDP" },
-    { IP_PROTO_TRUNK1,  "Trunk-1" },
-    { IP_PROTO_TRUNK2,  "Trunk-2" },
-    { IP_PROTO_LEAF1,   "Leaf-1" },
-    { IP_PROTO_LEAF2,   "Leaf-2" },
-    { IP_PROTO_RDP,     "Reliable Data" },
-    { IP_PROTO_IRT,     "IRT" },
-    { IP_PROTO_TP,	"ISO TP4" },
-    { IP_PROTO_BULK,    "Bulk Data" },
-    { IP_PROTO_MFE_NSP, "MFE NSP" },
-    { IP_PROTO_MERIT,   "Merit Internodal" },
-    { IP_PROTO_SEP,     "Sequential Exchange" },
-    { IP_PROTO_3PC,     "3rd Party Connect" },
-    { IP_PROTO_IDPR,    "Interdomain routing" },
-    { IP_PROTO_XTP,     "XTP" },
-    { IP_PROTO_DDP,     "Datagram delivery"},
-    { IP_PROTO_CMTP,    "Control Message" },
-    { IP_PROTO_TPPP,    "TP++" },
-    { IP_PROTO_IL,      "IL" },
-    { IP_PROTO_IPV6,	"IPv6" },
-    { IP_PROTO_SDRP,    "Source demand routing" },
-    { IP_PROTO_ROUTING,	"IPv6 routing" },
-    { IP_PROTO_FRAGMENT,"IPv6 fragment" },
-    { IP_PROTO_IDRP,    "IDRP" },
-    { IP_PROTO_RSVP,	"RSVP" },
-    { IP_PROTO_GRE,	"GRE" },
-    { IP_PROTO_MHRP,    "MHRP" },
-    { IP_PROTO_BNA,     "BNA" },
-    { IP_PROTO_ESP,	"ESP" },
-    { IP_PROTO_AH,	"AH" },
-    { IP_PROTO_INSLP,   "INSLP" },
-    { IP_PROTO_SWIPE,   "SWIPE" },
-    { IP_PROTO_NARP,    "NBMA ARP"},
-    { IP_PROTO_TLSP,    "TLSP Kryptonet" },
-    { IP_PROTO_SKIP,    "SKIP" },
-    { IP_PROTO_ICMPV6,	"ICMPv6" },
-    { IP_PROTO_NONE,	"IPv6 no next header" },
-    { IP_PROTO_DSTOPTS,	"IPv6 destination option" },
-    { IP_PROTO_MIPV6,	"Mobile IPv6" },
-    { IP_PROTO_SATEXPAK,"SATNET EXPAK" },
-    { IP_PROTO_KRYPTOLAN, "Kryptolan" },
-    { IP_PROTO_RVD,     "Remote Virtual Disk" },
-    { IP_PROTO_IPPC,    "IPPC" },
-    { IP_PROTO_SATMON,  "SATNET Monitoring" },
-    { IP_PROTO_VISA,    "VISA" },
-    { IP_PROTO_IPCV,    "IPCV" },
-    { IP_PROTO_CPNX,    "CPNX" },
-    { IP_PROTO_CPHB,    "CPHB" },
-    { IP_PROTO_WSN,     "Wang Span" },
-    { IP_PROTO_PVP,     "Packet Video" },
-    { IP_PROTO_BRSATMON,"Backroom SATNET Mon" },
-    { IP_PROTO_SUNND,   "Sun ND Protocol" },
-    { IP_PROTO_WBMON,   "Wideband Mon" },
-    { IP_PROTO_WBEXPAK, "Wideband Expak" },
-    { IP_PROTO_EON,	"EON" },
-    { IP_PROTO_VMTP,    "VMTP" },
-    { IP_PROTO_SVMTP,   "Secure VMTP" },
-    { IP_PROTO_VINES,	"VINES" },
-    { IP_PROTO_TTP,     "TTP" },
-    { IP_PROTO_NSFNETIGP,"NSFNET IGP" },
-    { IP_PROTO_DGP,     "Dissimilar Gateway" },
-    { IP_PROTO_TCF,     "TCF" },
-    { IP_PROTO_EIGRP,	"EIGRP" },
-    { IP_PROTO_OSPF,	"OSPF IGP" },
-    { IP_PROTO_SPRITE,  "Sprite RPC" },
-    { IP_PROTO_LARP,    "Locus ARP" },
-    { IP_PROTO_MTP,     "Multicast Transport" },
-    { IP_PROTO_AX25,    "AX.25 Frames" },
-    { IP_PROTO_IPINIP,  "IP in IP" },
-    { IP_PROTO_MICP,    "MICP" },
-    { IP_PROTO_SCCCP,   "Semaphore" },
-    { IP_PROTO_ETHERIP, "Ether in IP" },
-    { IP_PROTO_ENCAP,	"ENCAP" },
-    { IP_PROTO_GMTP,    "GMTP" },
-    { IP_PROTO_IFMP,    "Ipsilon Flow" },
-    { IP_PROTO_PNNI,    "PNNI over IP" },
-    { IP_PROTO_PIM,	"PIM" },
-    { IP_PROTO_ARIS,    "ARIS" },
-    { IP_PROTO_SCPS,    "SCPS" },
-    { IP_PROTO_QNX,     "QNX" },
-    { IP_PROTO_AN,      "Active Networks" },
-    { IP_PROTO_IPCOMP,	"IPComp" },
-    { IP_PROTO_SNP,     "Sitara Networks" },
-    { IP_PROTO_COMPAQ,  "Compaq Peer" },
-    { IP_PROTO_IPX,     "IPX IN IP" },
-    { IP_PROTO_VRRP,	"VRRP" },
-    { IP_PROTO_PGM,     "PGM" },
-    { IP_PROTO_L2TP,    "Layer 2 Tunneling" },
-    { IP_PROTO_DDX,     "DDX" },
-    { IP_PROTO_IATP,    "IATP" },
-    { IP_PROTO_STP,     "STP" },
-    { IP_PROTO_SRP,     "SpectraLink" },
-    { IP_PROTO_UTI,     "UTI" },
-    { IP_PROTO_SMP,     "SMP" },
-    { IP_PROTO_SM,      "SM" },
-    { IP_PROTO_PTP,     "PTP" },
-    { IP_PROTO_ISIS,    "ISIS over IP" },
-    { IP_PROTO_FIRE,    "FIRE" },
-    { IP_PROTO_CRTP,    "CRTP" },
-    { IP_PROTO_CRUDP,   "CRUDP" },
-    { IP_PROTO_SSCOPMCE,"SSCOPMCE" },
-    { IP_PROTO_IPLT,    "IPLT" },
-    { IP_PROTO_SPS,     "Secure Packet" },
-    { IP_PROTO_PIPE,    "PIPE" },
-    { IP_PROTO_SCTP,    "SCTP" },
-    { IP_PROTO_FC,      "Fibre Channel" },
-    { IP_PROTO_RSVPE2EI,"RSVP E2EI" },
-    { IP_PROTO_NCS_HEARTBEAT,"Novell NCS Heartbeat" },
-    { 0,		NULL },
-};
+#include "ipproto.h"
 
 const char *ipprotostr(int proto) {
     static char buf[128];
diff -Naur ethereal-0.9.16/ipproto.h ethereal-0.9.16_new/ipproto.h
--- ethereal-0.9.16/ipproto.h	2003-11-03 09:12:35.000000000 +1100
+++ ethereal-0.9.16_new/ipproto.h	2003-11-26 19:27:45.000000000 +1100
@@ -170,6 +170,55 @@
 #define IP_PROTO_RSVPE2EI       134             /* RSVP E2E Ignore - RFC3175 */
 #define IP_PROTO_NCS_HEARTBEAT  224             /* Novell NCS Heartbeat - http://support.novell.com/cgi-bin/search/searchtid.cgi?/10071158.htm */
 
+#include "epan/value_string.h"
+
 extern const char *ipprotostr(int proto);
 
+static const value_string ipproto_val[] = {
+    { IP_PROTO_ICMP,	"ICMP" },
+    { IP_PROTO_IGMP,	"IGMP" },
+    { IP_PROTO_EIGRP,	"EIGRP" },
+    { IP_PROTO_IGRP,	"IGRP" },
+    { IP_PROTO_TCP,	"TCP" },
+    { IP_PROTO_UDP,	"UDP" },
+    { IP_PROTO_OSPF,	"OSPF" },
+#if 0
+    { IP_PROTO_IP,	"IPv4" },
+#endif
+    { IP_PROTO_HOPOPTS,	"IPv6 hop-by-hop option" },
+    { IP_PROTO_ICMP,	"ICMP" },
+    { IP_PROTO_IGMP,	"IGMP" },
+    { IP_PROTO_GGP,	"GGP" },
+    { IP_PROTO_IPIP,	"IPIP" },
+#if 0
+    { IP_PROTO_IPV4,	"IPv4" },
+#endif
+    { IP_PROTO_EGP,	"EGP" },
+    { IP_PROTO_PUP,	"PUP" },
+    { IP_PROTO_UDP,	"UDP" },
+    { IP_PROTO_IDP,	"IDP" },
+    { IP_PROTO_TP,	"TP" },
+    { IP_PROTO_IPV6,	"IPv6" },
+    { IP_PROTO_ROUTING,	"IPv6 routing" },
+    { IP_PROTO_FRAGMENT,"IPv6 fragment" },
+    { IP_PROTO_RSVP,	"RSVP" },
+    { IP_PROTO_GRE,	"GRE" },
+    { IP_PROTO_ESP,	"ESP" },
+    { IP_PROTO_AH,	"AH" },
+    { IP_PROTO_ICMPV6,	"ICMPv6" },
+    { IP_PROTO_NONE,	"IPv6 no next header" },
+    { IP_PROTO_DSTOPTS,	"IPv6 destination option" },
+    { IP_PROTO_MIPV6,	"Mobile IPv6" },
+    { IP_PROTO_EON,	"EON" },
+    { IP_PROTO_OSPF,	"OSPF" },
+    { IP_PROTO_ENCAP,	"ENCAP" },
+    { IP_PROTO_PIM,	"PIM" },
+    { IP_PROTO_IPCOMP,	"IPComp" },
+    { IP_PROTO_VRRP,	"VRRP" },
+    { IP_PROTO_VINES,	"VINES" },
+    { IP_PROTO_PGM,     "PGM" },
+    { IP_PROTO_SCTP,    "SCTP" },
+    { 0,		NULL },
+};
+
 #endif /* ipproto.h */
diff -Naur ethereal-0.9.16/Makefile.am ethereal-0.9.16_new/Makefile.am
--- ethereal-0.9.16/Makefile.am	2003-11-03 04:15:17.000000000 +1100
+++ ethereal-0.9.16_new/Makefile.am	2003-11-26 19:27:45.000000000 +1100
@@ -84,386 +84,12 @@
 	nasreq.xml sunping.xml
 
 DISSECTOR_SRC = \
-	packet-aarp.c  \
-	packet-acap.c  \
-	packet-afp.c   \
-	packet-afs.c   \
-	packet-aim.c   \
-	packet-ajp13.c		\
-	packet-alcap.c \
-	packet-ans.c   \
-	packet-ansi_a.c   \
-	packet-ansi_637.c   \
-	packet-ansi_683.c   \
-	packet-ansi_map.c   \
-	packet-aodv.c  \
-	packet-arcnet.c \
-	packet-arp.c   \
-	packet-asap.c  \
-	packet-ascend.c\
-	packet-asf.c   \
-	packet-atalk.c \
-	packet-atm.c   \
-	packet-auto_rp.c   \
-	packet-bacapp.c   \
-	packet-bacnet.c   \
-	packet-beep.c \
-	packet-bgp.c   \
-	packet-bofl.c  \
-	packet-bootp.c \
-	packet-bootparams.c \
-	packet-bpdu.c  \
-	packet-brdwlk.c \
-	packet-bssap.c \
-	packet-bssgp.c \
-	packet-bvlc.c \
-	packet-cdp.c   \
-	packet-cgmp.c  \
-	packet-chdlc.c  \
-	packet-cisco-oui.c \
-	packet-clearcase.c  \
-	packet-clip.c  \
-	packet-clnp.c  \
-	packet-cops.c  \
-	packet-cosine.c  \
-	packet-cpha.c  \
-	packet-cups.c  \
-	packet-data.c  \
-	packet-dccp.c \
-	packet-dcerpc.c  \
-	packet-dcerpc-afs4int.c  \
-	packet-dcerpc-atsvc.c \
-	packet-dcerpc-bossvr.c  \
-	packet-dcerpc-browser.c  \
-	packet-dcerpc-butc.c  \
-	packet-dcerpc-cds_clerkserver.c  \
-	packet-dcerpc-cds_solicit.c  \
-	packet-dcerpc-conv.c  \
-	packet-dcerpc-cprpc_server.c  \
-	packet-dcerpc-dce122.c \
-	packet-dcerpc-dfs.c \
-	packet-dcerpc-dnsserver.c \
-	packet-dcerpc-drsuapi.c \
-	packet-dcerpc-dtsprovider.c \
-	packet-dcerpc-dtsstime_req.c \
-	packet-dcerpc-epm.c  \
-	packet-dcerpc-fldb.c  \
-	packet-dcerpc-ftserver.c \
-	packet-dcerpc-initshutdown.c \
-	packet-dcerpc-krb5rpc.c \
-	packet-dcerpc-lsa.c \
-	packet-dcerpc-lsa-ds.c \
-	packet-dcerpc-mapi.c  \
-	packet-dcerpc-messenger.c  \
-	packet-dcerpc-mgmt.c  \
-	packet-dcerpc-ndr.c  \
-	packet-dcerpc-netlogon.c \
-	packet-dcerpc-nspi.c \
-	packet-dcerpc-oxid.c  \
-	packet-dcerpc-reg.c \
-	packet-dcerpc-remact.c  \
-	packet-dcerpc-rep_proc.c  \
-	packet-dcerpc-roverride.c  \
-	packet-dcerpc-rpriv.c  \
-	packet-dcerpc-rs_acct.c  \
-	packet-dcerpc-rs_attr.c  \
-	packet-dcerpc-rs_bind.c  \
-	packet-dcerpc-rs_misc.c  \
-	packet-dcerpc-rs_pgo.c  \
-	packet-dcerpc-rs_repadm.c  \
-	packet-dcerpc-rs_replist.c  \
-	packet-dcerpc-rs_unix.c  \
-	packet-dcerpc-rsec_login.c  \
-	packet-dcerpc-samr.c \
-	packet-dcerpc-secidmap.c \
-	packet-dcerpc-spoolss.c \
-	packet-dcerpc-srvsvc.c \
-	packet-dcerpc-svcctl.c \
-	packet-dcerpc-tapi.c \
-	packet-dcerpc-tkn4int.c \
-	packet-dcerpc-ubikdisk.c \
-	packet-dcerpc-ubikvote.c \
-	packet-dcerpc-update.c \
-	packet-dcerpc-wkssvc.c \
-	packet-ddtp.c  \
-	packet-dec-bpdu.c \
-	packet-dhcpv6.c \
-	packet-diameter.c \
-	packet-diffserv-mpls-common.c \
-	packet-distcc.c \
-	packet-dlsw.c  \
-	packet-dns.c   \
-	packet-dsi.c   \
-	packet-dvmrp.c \
-	packet-eap.c \
-	packet-eapol.c \
-	packet-echo.c \
-	packet-edonkey.c \
-	packet-eigrp.c \
-	packet-enc.c	\
-	packet-enip.c   \
-	packet-esis.c  \
-	packet-eth.c   \
-	packet-etherip.c	\
-	packet-ethertype.c   \
-	packet-fc.c \
-	packet-fcct.c \
-	packet-fcdns.c \
-	packet-fcels.c \
-	packet-fcfcs.c \
-	packet-fcfzs.c \
-	packet-fcip.c \
-	packet-fclctl.c \
-	packet-fcp.c \
-	packet-fcsb3.c \
-	packet-fcsp.c \
-	packet-fcswils.c \
-	packet-fddi.c  \
-	packet-fix.c  \
-	packet-fr.c    \
-	packet-frame.c  \
-	packet-ftp.c   \
-	packet-fw1.c   \
-	packet-giop.c  \
-	packet-gmrp.c \
-	packet-gnutella.c \
-	packet-gprs-ns.c \
-	packet-gre.c   \
-	packet-gsm_a.c   \
-	packet-gsm_sms.c   \
-	packet-gssapi.c \
-	packet-gtp.c   \
-	packet-gvrp.c  \
-	packet-h1.c    \
-	packet-h225.c  \
-	packet-h245.c  \
-	packet-h261.c  \
-	packet-h263.c  \
-	packet-h450.c  \
-	packet-hclnfsd.c  \
-	packet-hpext.c \
-	packet-hsrp.c  \
-	packet-http.c  \
-	packet-hyperscsi.c \
-	packet-iapp.c  \
-	packet-ib.c  \
-	packet-icap.c  \
-	packet-icmpv6.c\
-	packet-icp.c   \
-	packet-icq.c   \
-	packet-ieee80211.c \
-	packet-ieee8023.c \
-	packet-igmp.c  \
-	packet-igrp.c  \
-	packet-imap.c   \
-	packet-ip.c    \
-	packet-ipfc.c    \
-	packet-ipmi.c  \
-	packet-ipp.c   \
-	packet-ipsec.c \
-	packet-ipsec-udp.c \
-	packet-ipv6.c  \
-	packet-ipx.c   \
-	packet-ipxwan.c \
-	packet-irc.c   \
-	packet-isakmp.c\
-	packet-iscsi.c \
-	packet-isdn.c \
-	packet-isis.c  \
-	packet-isis-clv.c \
-	packet-isis-hello.c \
-	packet-isis-lsp.c \
-	packet-isis-snp.c \
-	packet-isl.c   \
-	packet-isns.c \
-	packet-isup.c  \
-	packet-iua.c   \
-	packet-jabber.c \
-	packet-kadm5.c \
-	packet-kerberos.c \
-	packet-klm.c   \
-	packet-l2tp.c  \
-	packet-lapb.c  \
-	packet-lapbether.c \
-	packet-lapd.c  \
-	packet-laplink.c  \
-	packet-ldap.c  \
-	packet-ldp.c   \
-	packet-llc.c   \
-	packet-lmi.c   \
-	packet-lmp.c   \
-	packet-lpd.c   \
-	packet-lwapp.c \
-	packet-m2pa.c  \
-	packet-m2tp.c  \
-	packet-m2ua.c  \
-	packet-m3ua.c  \
-	packet-mbtcp.c \
-	packet-mdshdr.c \
-	packet-mip.c  \
-	packet-mip6.c  \
-	packet-mmse.c  \
-	packet-mount.c \
-	packet-mpeg1.c  \
-	packet-mpls.c \
-	packet-mrdisc.c \
-	packet-msdp.c  \
-	packet-msn-messenger.c \
-	packet-msnip.c \
-	packet-msproxy.c \
-	packet-mtp2.c \
-	packet-mtp3.c \
-	packet-mtp3mg.c \
-	packet-mysql.c \
-	packet-nbipx.c \
-	packet-nbns.c  \
-	packet-ncp.c   \
-	packet-ncp2222.c   \
-	packet-ndmp.c  \
-	packet-ndps.c  \
-	packet-netbios.c \
-	packet-netflow.c \
-	packet-nfs.c   \
-	packet-nfsacl.c \
-	packet-nfsauth.c \
-	packet-nisplus.c \
-	packet-nlm.c   \
-	packet-nlsp.c  \
-	packet-nntp.c  \
-	packet-nt-oui.c \
-	packet-nt-sonmp.c \
-	packet-nt-tpcp.c \
-	packet-ntlmssp.c  \
-	packet-ntp.c  \
-	packet-null.c  \
-	packet-osi.c   \
-	packet-osi-options.c \
-	packet-ospf.c  \
-	packet-pcnfsd.c \
-	packet-per.c \
-	packet-pflog.c \
-	packet-pgm.c   \
-	packet-pim.c   \
-	packet-pop.c   \
-	packet-portmap.c   \
-	packet-ppp.c   \
-	packet-pppoe.c \
-	packet-pptp.c  \
-	packet-prism.c \
-	packet-q2931.c \
-	packet-q931.c  \
-	packet-q933.c  \
-	packet-qllc.c  \
-	packet-quake.c \
-	packet-quake2.c \
-	packet-quake3.c \
-	packet-quakeworld.c \
-	packet-radius.c\
-	packet-ranap.c \
-	packet-raw.c   \
-	packet-rip.c   \
-	packet-ripng.c \
-	packet-rlogin.c \
-	packet-rmcp.c  \
-	packet-rmi.c \
-	packet-rmp.c   \
-	packet-rpc.c   \
-	packet-rpl.c   \
-	packet-rquota.c \
-	packet-rsh.c   \
-	packet-rstat.c \
-	packet-rsvp.c  \
-	packet-rsync.c \
-	packet-rtcp.c  \
-	packet-rtp.c   \
-	packet-rtp-events.c \
-	packet-rtsp.c  \
-	packet-rwall.c \
-	packet-rx.c  \
-	packet-sadmind.c \
-	packet-sap.c   \
-	packet-sccp.c  \
-	packet-sccpmg.c  \
-	packet-scsi.c  \
-	packet-sctp.c  \
-	packet-sdlc.c  \
-	packet-sdp.c   \
-	packet-sflow.c \
-	packet-sip.c   \
-	packet-skinny.c   \
-	packet-slimp3.c   \
-	packet-sll.c   \
-	packet-slowprotocols.c \
-	packet-smb.c   \
-	packet-smb-browse.c \
-	packet-smb-common.c \
-	packet-smb-logon.c \
-	packet-smb-mailslot.c \
-	packet-smb-pipe.c \
-	packet-smb-sidsnooping.c \
-	packet-smpp.c \
-	packet-smtp.c \
-	packet-sna.c   \
-	packet-snaeth.c \
-	packet-snmp.c	\
-	packet-socks.c \
-	packet-spnego.c \
-	packet-spray.c \
-	packet-srvloc.c \
-	packet-sscop.c \
-	packet-ssh.c   \
-	packet-ssl.c   \
-	packet-stat.c   \
-	packet-stat-notify.c \
-	packet-stun.c  \
-	packet-sua.c   \
-	packet-syslog.c \
-	packet-t38.c	\
-	packet-tacacs.c \
-	packet-tcap.c   \
-	packet-tcp.c   \
-	packet-tds.c   \
-	packet-telnet.c\
-	packet-teredo.c\
-	packet-tftp.c  \
-	packet-time.c  \
-	packet-tns.c \
-	packet-tpkt.c  \
-	packet-tr.c    \
-	packet-trmac.c \
-	packet-tsp.c \
-	packet-tzsp.c  \
-	packet-ucp.c   \
-	packet-udp.c   \
-	packet-v120.c \
-	packet-vines.c \
-	packet-vj.c   \
-	packet-vlan.c \
-	packet-vrrp.c \
-	packet-vtp.c  \
-	packet-wap.c \
-	packet-wbxml.c \
-	packet-wccp.c \
-	packet-wcp.c \
-	packet-wfleet-hdlc.c \
-	packet-who.c  \
-	packet-wlancap.c \
-	packet-wsp.c \
-	packet-wtls.c \
-	packet-wtp.c \
-	packet-x11.c   \
-	packet-x25.c   \
-	packet-x29.c   \
-	packet-xdmcp.c \
-	packet-xot.c   \
-	packet-xyplex.c   \
-	packet-yhoo.c  \
-	packet-ymsg.c  \
-	packet-ypbind.c \
-	packet-yppasswd.c \
-	packet-ypserv.c \
-	packet-ypxfr.c \
-	packet-zebra.c
+packet-eth.c packet-ethertype.c packet-frame.c packet-ip.c packet-tcp.c	packet-dns.c	packet-data.c \
+  	packet-http.c \
+  	packet-smtp.c \
+  	packet-udp.c \
+	packet-pop.c
+
 
 if HAVE_PLUGINS
 plugin_libs = \
@@ -785,7 +411,6 @@
 	llcsaps.h      \
 	nlpid.h        \
 	oui.h          \
-	packet-dcerpc-nt.c \
 	pcap-util.c    \
 	pcap-util.h    \
 	pcap-util-int.h \
@@ -825,6 +450,7 @@
 	xmlstub.c      \
 	xmlstub.h
 
+
 BUILT_SOURCES = \
 	x11-declarations.h \
 	x11-register-info.h
@@ -909,28 +535,11 @@
 	$(plugin_ldadd)			\
 	@PCAP_LIBS@ @GTK_LIBS@ @ADNS_LIBS@
 
-TETHEREAL_TAP_SRC = \
-	tap-bootpstat.c		\
-	tap-dcerpcstat.c	\
-	tap-h225counter.c	\
-	tap-httpstat.c		\
-	tap-iostat.c		\
-	tap-iousers.c		\
-	tap-mgcpstat.c		\
-	tap-protocolinfo.c	\
-	tap-protohierstat.c	\
-	tap-rpcstat.c		\
-	tap-rpcprogs.c		\
-	tap-smbsids.c		\
-	tap-smbstat.c		\
-	tap-wspstat.c
-
 tethereal_SOURCES = \
 	$(DISSECTOR_SRC) \
 	$(ETHEREAL_COMMON_SRC) \
-	$(TETHEREAL_TAP_SRC) \
-	tethereal-tap-register.c \
 	register.c     \
+	sql.c \
 	tethereal.c
 
 # Additional libs that I know how to build. These will be
diff -Naur ethereal-0.9.16/packet-dns.c ethereal-0.9.16_new/packet-dns.c
--- ethereal-0.9.16/packet-dns.c	2003-10-09 08:44:33.000000000 +1000
+++ ethereal-0.9.16_new/packet-dns.c	2003-11-26 19:27:45.000000000 +1100
@@ -42,9 +42,18 @@
 #include "packet-dns.h"
 #include "packet-tcp.h"
 #include "prefs.h"
+#include "sql.h"
+
+extern int frame_no;
+extern GString* additional_sql;
 
 static int proto_dns = -1;
+static int proto_dns_data = -1;
 static int hf_dns_length = -1;
+static int hf_dns_name = -1;
+static int hf_dns_type = -1;
+static int hf_dns_class = -1;
+static int hf_dns_data = -1;
 static int hf_dns_flags = -1;
 static int hf_dns_flags_response = -1;
 static int hf_dns_flags_opcode = -1;
@@ -773,12 +782,24 @@
 
     proto_tree_add_text(q_tree, tvb, offset, name_len, "Name: %s", name);
     offset += name_len;
-
     proto_tree_add_text(q_tree, tvb, offset, 2, "Type: %s", long_type_name);
     offset += 2;
-
     proto_tree_add_text(q_tree, tvb, offset, 2, "Class: %s", class_name);
     offset += 2;
+
+    
+    {
+      char t[MAX_NODE_NAME_LEN];
+
+
+      snprintf(t,MAX_NODE_NAME_LEN,"%d",frame_no+1);
+      //      add_field("key_id",strdup(t));
+      add_protocol("dns_data");
+      add_field_str("dns_data.name",(name));
+      add_field_str("dns_data.type",(type_name));
+      add_field_str("dns_data.class",(class_name));
+       //      g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\";",frame_no+1,name,type_name,class_name);
+    };
   }
 
   return data_offset - data_start;
@@ -946,6 +967,13 @@
 	proto_item_append_text(trr, ", addr %s", ip_to_str(addr));
 	proto_tree_add_text(rr_tree, tvb, cur_offset, 4, "Addr: %s",
 		     ip_to_str(addr));
+
+	add_protocol("dns_data");
+	add_field_str("dns_data.name",(name));
+	add_field_str("dns_data.type",(type_name));
+	add_field_str("dns_data.class",(class_name));
+	add_field_str("dns_data.data",(ip_to_str(addr)));
+	//	g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\",data=\"%s\";",frame_no+1,name,type_name,class_name,ip_to_str(addr));
       }
       if ((class & 0x7f) == C_IN) {
 	memcpy(&addr_int, addr, sizeof(addr_int));
@@ -966,6 +994,14 @@
 	proto_item_append_text(trr, ", ns %s", ns_name);
 	proto_tree_add_text(rr_tree, tvb, cur_offset, ns_name_len, "Name server: %s",
 			ns_name);
+
+	add_protocol("dns_data");
+	add_field_str("dns_data.name",(name));
+	add_field_str("dns_data.type",(type_name));
+	add_field_str("dns_data.class",(class_name));
+	add_field_str("dns_data.data",(ns_name));
+
+	//	g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\",data=\"%s\";",frame_no+1,name,type_name,class_name,ns_name);
       }
     }
     break;
@@ -982,6 +1018,15 @@
 	proto_item_append_text(trr, ", cname %s", cname);
 	proto_tree_add_text(rr_tree, tvb, cur_offset, cname_len, "Primary name: %s",
 			cname);
+
+	add_protocol("dns_data");
+	add_field_str("dns_data.name",(name));
+	add_field_str("dns_data.type",(type_name));
+	add_field_str("dns_data.class",(class_name));
+	add_field_str("dns_data.data",(cname));
+
+	//	g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\",data=\"%s\";",frame_no+1,name,type_name,class_name,cname);
+
       }
     }
     break;
@@ -1051,6 +1096,15 @@
 	proto_item_append_text(trr, ", %s", pname);
 	proto_tree_add_text(rr_tree, tvb, cur_offset, pname_len, "Domain name: %s",
 			pname);
+
+	add_protocol("dns_data");
+	add_field_str("dns_data.name",(name));
+	add_field_str("dns_data.type",(type_name));
+	add_field_str("dns_data.class",(class_name));
+	add_field_str("dns_data.data",(pname));
+
+	//	g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\",data=\"%s\";",frame_no+1,name,type_name,class_name,pname);
+
       }
       break;
     }
@@ -1171,6 +1225,14 @@
 	proto_tree_add_text(rr_tree, tvb, cur_offset, 2, "Preference: %u", preference);
 	proto_tree_add_text(rr_tree, tvb, cur_offset + 2, mx_name_len, "Mail exchange: %s",
 			mx_name);
+	add_protocol("dns_data");
+	add_field_str("dns_data.name",(name));
+	add_field_str("dns_data.type",(type_name));
+	add_field_str("dns_data.class",(class_name));
+	add_field_str("dns_data.data",(mx_name));
+
+	//	g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\",data=\"%s\";",frame_no+1,name,type_name,class_name,mx_name);
+
       }
     }
     break;
@@ -1187,6 +1249,15 @@
 	  txt_len = tvb_get_guint8(tvb, txt_offset);
 	  proto_tree_add_text(rr_tree, tvb, txt_offset, 1 + txt_len,
 	   "Text: %.*s", txt_len, tvb_get_ptr(tvb, txt_offset + 1, txt_len));
+
+	add_protocol("dns_data");
+	add_field_str("dns_data.name",(name));
+	add_field_str("dns_data.type",(type_name));
+	add_field_str("dns_data.class",(class_name));
+	add_field_str("dns_data.data",(tvb_get_ptr(tvb, txt_offset + 1, txt_len)));
+
+		  //	  g_string_sprintfa(additional_sql,"insert into dns_data set key_id=\"%d\",name=\"%s\",type=\"%s\",class=\"%s\",data=\"%s\";",frame_no+1,name,type_name,class_name,tvb_get_ptr(tvb, txt_offset + 1, txt_len));
+	
 	  txt_offset += 1 + txt_len;
 	  rr_len -= 1 + txt_len;
 	}
@@ -1856,7 +1927,7 @@
       }
     }
     break;
-
+ 
     /* TODO: parse more record types */
 
   default:
@@ -2139,11 +2210,11 @@
     { &hf_dns_length,
       { "Length",		"dns.length",
 	FT_UINT16, BASE_DEC, NULL, 0x0,
-	"Length of DNS-over-TCP request or response", HFILL }},
+	"Length of DNS-over-TCP request or response", SQLFILL }},
     { &hf_dns_flags,
       { "Flags",		"dns.flags",
 	FT_UINT16, BASE_HEX, NULL, 0x0,
-	"", HFILL }},
+	"", SQLFILL }},
     { &hf_dns_flags_response,
       { "Response",		"dns.flags.response",
 	FT_BOOLEAN, 16, TFS(&tfs_flags_response), F_RESPONSE,
@@ -2187,24 +2258,44 @@
     { &hf_dns_transaction_id,
       { "Transaction ID",      	"dns.id",
 	FT_UINT16, BASE_HEX, NULL, 0x0,
-	"Identification of transaction", HFILL }},
+	"Identification of transaction", SQLFILL }},
     { &hf_dns_count_questions,
       { "Questions",		"dns.count.queries",
 	FT_UINT16, BASE_DEC, NULL, 0x0,
-	"Number of queries in packet", HFILL }},
+	"Number of queries in packet", SQLFILL }},
     { &hf_dns_count_answers,
       { "Answer RRs",		"dns.count.answers",
 	FT_UINT16, BASE_DEC, NULL, 0x0,
-	"Number of answers in packet", HFILL }},
+	"Number of answers in packet", SQLFILL }},
     { &hf_dns_count_auth_rr,
       { "Authority RRs",       	"dns.count.auth_rr",
 	FT_UINT16, BASE_DEC, NULL, 0x0,
-	"Number of authoritative records in packet", HFILL }},
+	"Number of authoritative records in packet", SQLFILL }},
     { &hf_dns_count_add_rr,
       { "Additional RRs",      	"dns.count.add_rr",
 	FT_UINT16, BASE_DEC, NULL, 0x0,
-	"Number of additional records in packet", HFILL }}
+	"Number of additional records in packet", SQLFILL }}
   };
+
+  static hf_register_info hf_data[] = {
+    { &hf_dns_name,
+      { "name",		"dns_data.name",
+	FT_STRING, BASE_NONE, NULL, 0x0,
+	"dns name", SQLFILL }},
+    { &hf_dns_type,
+      { "Type",		"dns_data.type",
+	FT_STRING, BASE_NONE, NULL, 0x0,
+	"", SQLFILL }},
+    { &hf_dns_class,
+      { "Class",		"dns_data.class",
+	FT_STRING, BASE_NONE, NULL, 0x0,
+	"", SQLFILL }},
+    { &hf_dns_data,
+      { "Data",		"dns_data.data",
+	FT_STRING, BASE_NONE, NULL, 0x0,
+	"", SQLFILL }},
+ };
+
   static gint *ett[] = {
     &ett_dns,
     &ett_dns_qd,
@@ -2218,9 +2309,14 @@
   module_t *dns_module;
 
   proto_dns = proto_register_protocol("Domain Name Service", "DNS", "dns");
+  proto_register_sql_protocol(proto_dns);
   proto_register_field_array(proto_dns, hf, array_length(hf));
   proto_register_subtree_array(ett, array_length(ett));
 
+  proto_dns_data = proto_register_protocol("Domain Name Service - Data", "DNS Data", "dns_data");
+  proto_register_field_array(proto_dns_data, hf_data, array_length(hf_data));
+  proto_register_sql_protocol(proto_dns_data);
+
   dns_module = prefs_register_protocol(proto_dns, NULL);
   prefs_register_bool_preference(dns_module, "desegment_dns_messages",
     "Desegment all DNS messages spanning multiple TCP segments",
diff -Naur ethereal-0.9.16/packet-eth.c ethereal-0.9.16_new/packet-eth.c
--- ethereal-0.9.16/packet-eth.c	2003-10-04 13:42:34.000000000 +1000
+++ ethereal-0.9.16_new/packet-eth.c	2003-11-26 19:27:45.000000000 +1100
@@ -126,7 +126,7 @@
        01-00-0C-00-00 for ISL frames. */
     if (pd[offset] == 0x01 && pd[offset+1] == 0x00 && pd[offset+2] == 0x0C
 	&& pd[offset+3] == 0x00 && pd[offset+4] == 0x00) {
-      capture_isl(pd, offset, len, ld);
+      //capture_isl(pd, offset, len, ld);
       return;
     }
 
@@ -145,10 +145,10 @@
 
   switch (ethhdr_type) {
     case ETHERNET_802_3:
-      capture_ipx(ld);
+      //capture_ipx(ld);
       break;
     case ETHERNET_802_2:
-      capture_llc(pd, offset, len, ld);
+      //capture_llc(pd, offset, len, ld);
       break;
     case ETHERNET_II:
       capture_ethertype(etype, pd, offset, len, ld);
@@ -255,8 +255,8 @@
     proto_tree_add_ether_hidden(fh_tree, hf_eth_addr, tvb, 0, 6, dst_addr);
     proto_tree_add_ether_hidden(fh_tree, hf_eth_addr, tvb, 6, 6, src_addr);
 
-    dissect_802_3(ehdr->type, is_802_2, tvb, ETH_HEADER_SIZE, pinfo, tree, fh_tree,
-		  hf_eth_len, hf_eth_trailer, fcs_len);
+//    dissect_802_3(ehdr->type, is_802_2, tvb, ETH_HEADER_SIZE, pinfo, tree, fh_tree,
+//		  hf_eth_len, hf_eth_trailer, fcs_len);
   } else {
     if (eth_interpret_as_fw1_monitor) {
       call_dissector(fw1_handle, tvb, pinfo, tree);
@@ -392,20 +392,20 @@
 
 		{ &hf_eth_dst,
 		{ "Destination",	"eth.dst", FT_ETHER, BASE_NONE, NULL, 0x0,
-			"Destination Hardware Address", HFILL }},
+			"Destination Hardware Address", SQLFILL }},
 
 		{ &hf_eth_src,
 		{ "Source",		"eth.src", FT_ETHER, BASE_NONE, NULL, 0x0,
-			"Source Hardware Address", HFILL }},
+			"Source Hardware Address", SQLFILL }},
 
 		{ &hf_eth_len,
 		{ "Length",		"eth.len", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		/* registered here but handled in ethertype.c */
 		{ &hf_eth_type,
 		{ "Type",		"eth.type", FT_UINT16, BASE_HEX, VALS(etype_vals), 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 		{ &hf_eth_addr,
 		{ "Source or Destination Address", "eth.addr", FT_ETHER, BASE_NONE, NULL, 0x0,
 			"Source or Destination Hardware Address", HFILL }},
@@ -422,6 +422,7 @@
 	module_t *eth_module;
 
 	proto_eth = proto_register_protocol("Ethernet", "Ethernet", "eth");
+	proto_register_sql_protocol(proto_eth);
 	proto_register_field_array(proto_eth, hf, array_length(hf));
 	proto_register_subtree_array(ett, array_length(ett));
 
@@ -444,8 +445,8 @@
 	/*
 	 * Get a handle for the ISL dissector.
 	 */
-	isl_handle = find_dissector("isl");
-	fw1_handle = find_dissector("fw1");
+//	isl_handle = find_dissector("isl");
+//	fw1_handle = find_dissector("fw1");
 
 	eth_maybefcs_handle = create_dissector_handle(dissect_eth_maybefcs,
 	    proto_eth);
@@ -453,6 +454,6 @@
 
 	eth_handle = find_dissector("eth");
 	dissector_add("ethertype", ETHERTYPE_ETHBRIDGE, eth_handle);
-	dissector_add("chdlctype", ETHERTYPE_ETHBRIDGE, eth_handle);
-	dissector_add("gre.proto", ETHERTYPE_ETHBRIDGE, eth_handle);
+//	dissector_add("chdlctype", ETHERTYPE_ETHBRIDGE, eth_handle);
+//	dissector_add("gre.proto", ETHERTYPE_ETHBRIDGE, eth_handle);
 }
diff -Naur ethereal-0.9.16/packet-ethertype.c ethereal-0.9.16_new/packet-ethertype.c
--- ethereal-0.9.16/packet-ethertype.c	2003-10-09 08:44:33.000000000 +1000
+++ ethereal-0.9.16_new/packet-ethertype.c	2003-11-26 19:27:45.000000000 +1100
@@ -121,17 +121,17 @@
       capture_ip(pd, offset, len, ld);
       break;
     case ETHERTYPE_IPv6:
-      capture_ipv6(pd, offset, len, ld);
+      //capture_ipv6(pd, offset, len, ld);
       break;
     case ETHERTYPE_IPX:
-      capture_ipx(ld);
+      //capture_ipx(ld);
       break;
     case ETHERTYPE_VLAN:
-      capture_vlan(pd, offset, len, ld);
+      //capture_vlan(pd, offset, len, ld);
       break;
     case ETHERTYPE_VINES_IP:
     case ETHERTYPE_VINES_ECHO:
-      capture_vines(ld);
+      //capture_vines(ld);
       break;
     default:
       ld->other++;
diff -Naur ethereal-0.9.16/packet-frame.c ethereal-0.9.16_new/packet-frame.c
--- ethereal-0.9.16/packet-frame.c	2003-10-26 13:10:49.000000000 +1100
+++ ethereal-0.9.16_new/packet-frame.c	2003-11-26 19:27:45.000000000 +1100
@@ -253,7 +253,7 @@
 	static hf_register_info hf[] = {
 		{ &hf_frame_arrival_time,
 		{ "Arrival Time",		"frame.time", FT_ABSOLUTE_TIME, BASE_NONE, NULL, 0x0,
-			"Absolute time when this frame was captured", HFILL }},
+			"Absolute time when this frame was captured", SQLFILL }},
 
 		{ &hf_frame_time_delta,
 		{ "Time delta from previous packet",	"frame.time_delta", FT_RELATIVE_TIME, BASE_NONE, NULL,
@@ -271,11 +271,11 @@
 
 		{ &hf_frame_packet_len,
 		{ "Total Frame Length",		"frame.pkt_len", FT_UINT32, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_frame_capture_len,
 		{ "Capture Frame Length",	"frame.cap_len", FT_UINT32, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_frame_p2p_dir,
 		{ "Point-to-Point Direction",	"frame.p2p_dir", FT_UINT8, BASE_DEC, VALS(p2p_dirs), 0x0,
@@ -302,6 +302,7 @@
 	    "Wiretap encapsulation type", FT_UINT32, BASE_DEC);
 
 	proto_frame = proto_register_protocol("Frame", "Frame", "frame");
+	proto_register_sql_protocol(proto_frame);
 	proto_register_field_array(proto_frame, hf, array_length(hf));
 	proto_register_subtree_array(ett, array_length(ett));
 	register_dissector("frame",dissect_frame,proto_frame);
diff -Naur ethereal-0.9.16/packet-http.c ethereal-0.9.16_new/packet-http.c
--- ethereal-0.9.16/packet-http.c	2003-11-03 04:15:21.000000000 +1100
+++ ethereal-0.9.16_new/packet-http.c	2003-11-26 19:27:45.000000000 +1100
@@ -64,6 +64,9 @@
 static gint ett_http = -1;
 static gint ett_http_ntlmssp = -1;
 static gint ett_http_request = -1;
+static int hf_http_request_uri = -1;
+static int hf_http_request_headers = -1;
+  
 
 static dissector_handle_t data_handle;
 static dissector_handle_t http_handle;
@@ -596,7 +599,14 @@
 static void
 basic_request_dissector(tvbuff_t *tvb, proto_tree *tree, int req_strlen)
 {
+                 int linelen;
 	proto_tree_add_item(tree, hf_http_request_method, tvb, 0, req_strlen, FALSE);
+	//Find the end of the line:
+	linelen= tvb_find_guint8(tvb,req_strlen+1,-1,' ');
+	proto_tree_add_item(tree, hf_http_request_uri, tvb, req_strlen+1, linelen-req_strlen, FALSE);
+	//Now store the headers in a big variable
+	linelen= tvb_find_guint8(tvb,req_strlen+1,-1,'\n');
+	proto_tree_add_item(tree, hf_http_request_headers, tvb, linelen+1,-1, FALSE);
 }
 
 static void
@@ -787,15 +797,23 @@
 		"TRUE if HTTP request", HFILL }},
 	    { &hf_http_basic,
 	      { "Credentials",		"http.authbasic",
-		FT_STRING, BASE_NONE, NULL, 0x0, "", HFILL }},
+		FT_STRING, BASE_NONE, NULL, 0x0, "", SQLFILL }},
 	    { &hf_http_request_method,
 	      { "Request Method",	"http.request.method",
 		FT_STRING, BASE_NONE, NULL, 0x0,
-		"HTTP Request Method", HFILL }},
+		"HTTP Request Method", SQLFILL }},
 	    { &hf_http_response_code,
 	      { "Response Code",	"http.response.code",
 		FT_UINT16, BASE_DEC, NULL, 0x0,
 		"HTTP Response Code", HFILL }},
+ 	    { &hf_http_request_uri,
+ 	      { "Request URI",	"http.request.uri",
+ 		FT_STRING, BASE_NONE, NULL, 0x0,
+ 		"HTTP Request URI", SQLFILL }},
+ 	    { &hf_http_request_headers,
+ 	      { "Request Headers","http.request.headers",
+ 		FT_STRING, BASE_NONE, NULL, 0x0,
+ 		"HTTP Request Headers", SQLFILL }},
 	};
 	static gint *ett[] = {
 		&ett_http,
@@ -806,6 +824,7 @@
 
 	proto_http = proto_register_protocol("Hypertext Transfer Protocol",
 	    "HTTP", "http");
+	proto_register_sql_protocol(proto_http);
 	proto_register_field_array(proto_http, hf, array_length(hf));
 	proto_register_subtree_array(ett, array_length(ett));
         http_module = prefs_register_protocol(proto_http, NULL);
diff -Naur ethereal-0.9.16/packet-ip.c ethereal-0.9.16_new/packet-ip.c
--- ethereal-0.9.16/packet-ip.c	2003-10-20 10:19:52.000000000 +1000
+++ ethereal-0.9.16_new/packet-ip.c	2003-11-26 19:27:45.000000000 +1100
@@ -36,7 +36,6 @@
 
 #include <epan/packet.h>
 #include <epan/resolv.h>
-#include "ipproto.h"
 #include "ip_opts.h"
 #include "prefs.h"
 #include "reassemble.h"
@@ -49,6 +48,8 @@
 #include "packet-ip.h"
 #include "packet-ipsec.h"
 #include "in_cksum.h"
+//#include "ipproto.c"
+#include "ipproto.h"
 #include "nlpid.h"
 #include "tap.h"
 
@@ -1559,7 +1560,7 @@
 
 		{ &hf_ip_hdr_len,
 		{ "Header Length",	"ip.hdr_len", FT_UINT8, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_dsfield,
 		{ "Differentiated Services field",	"ip.dsfield", FT_UINT8, BASE_DEC, NULL, 0x0,
@@ -1611,19 +1612,19 @@
 
 		{ &hf_ip_len,
 		{ "Total Length",	"ip.len", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_id,
 		{ "Identification",	"ip.id", FT_UINT16, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_dst,
 		{ "Destination",	"ip.dst", FT_IPv4, BASE_NONE, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_src,
 		{ "Source",		"ip.src", FT_IPv4, BASE_NONE, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_addr,
 		{ "Source or Destination Address", "ip.addr", FT_IPv4, BASE_NONE, NULL, 0x0,
@@ -1631,7 +1632,7 @@
 
 		{ &hf_ip_flags,
 		{ "Flags",		"ip.flags", FT_UINT8, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_flags_df,
 		{ "Don't fragment",	"ip.flags.df", FT_BOOLEAN, 4, TFS(&flags_set_truth), IP_DF>>12,
@@ -1643,35 +1644,35 @@
 
 		{ &hf_ip_frag_offset,
 		{ "Fragment offset",	"ip.frag_offset", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_ttl,
 		{ "Time to live",	"ip.ttl", FT_UINT8, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_proto,
-		{ "Protocol",		"ip.proto", FT_UINT8, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+		{ "Protocol",		"ip.proto", FT_UINT8, BASE_HEX, VALS(ipproto_val), 0x0,
+			"", SQLFILL }},
 
 		{ &hf_ip_checksum,
 		{ "Header checksum",	"ip.checksum", FT_UINT16, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_checksum_bad,
 		{ "Bad Header checksum",	"ip.checksum_bad", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_ip_fragment_overlap,
 		{ "Fragment overlap",	"ip.fragment.overlap", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-			"Fragment overlaps with other fragments", HFILL }},
+			"Fragment overlaps with other fragments", SQLFILL }},
 
 		{ &hf_ip_fragment_overlap_conflict,
 		{ "Conflicting data in fragment overlap",	"ip.fragment.overlap.conflict", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-			"Overlapping fragments contained conflicting data", HFILL }},
+			"Overlapping fragments contained conflicting data", SQLFILL }},
 
 		{ &hf_ip_fragment_multiple_tails,
 		{ "Multiple tail fragments found",	"ip.fragment.multipletails", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-			"Several tails were found when defragmenting the packet", HFILL }},
+			"Several tails were found when defragmenting the packet", SQLFILL }},
 
 		{ &hf_ip_fragment_too_long_fragment,
 		{ "Fragment too long",	"ip.fragment.toolongfragment", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
@@ -1679,7 +1680,7 @@
 
 		{ &hf_ip_fragment_error,
 		{ "Defragmentation error", "ip.fragment.error", FT_FRAMENUM, BASE_NONE, NULL, 0x0,
-			"Defragmentation error due to illegal fragments", HFILL }},
+			"Defragmentation error due to illegal fragments", SQLFILL }},
 
 		{ &hf_ip_fragment,
 		{ "IP Fragment", "ip.fragment", FT_FRAMENUM, BASE_NONE, NULL, 0x0,
@@ -1708,6 +1709,7 @@
 	module_t *ip_module;
 
 	proto_ip = proto_register_protocol("Internet Protocol", "IP", "ip");
+	proto_register_sql_protocol(proto_ip);
 	proto_register_field_array(proto_ip, hf, array_length(hf));
 	proto_register_subtree_array(ett, array_length(ett));
 
@@ -1743,18 +1745,18 @@
         data_handle = find_dissector("data");
         ip_handle = find_dissector("ip");
 	dissector_add("ethertype", ETHERTYPE_IP, ip_handle);
-	dissector_add("ppp.protocol", PPP_IP, ip_handle);
-	dissector_add("ppp.protocol", ETHERTYPE_IP, ip_handle);
-	dissector_add("gre.proto", ETHERTYPE_IP, ip_handle);
-	dissector_add("gre.proto", GRE_WCCP, ip_handle);
-	dissector_add("llc.dsap", SAP_IP, ip_handle);
+//	dissector_add("ppp.protocol", PPP_IP, ip_handle);
+//	dissector_add("ppp.protocol", ETHERTYPE_IP, ip_handle);
+//	dissector_add("gre.proto", ETHERTYPE_IP, ip_handle);
+//	dissector_add("gre.proto", GRE_WCCP, ip_handle);
+//	dissector_add("llc.dsap", SAP_IP, ip_handle);
 	dissector_add("ip.proto", IP_PROTO_IPIP, ip_handle);
-	dissector_add("null.type", BSD_AF_INET, ip_handle);
-	dissector_add("chdlctype", ETHERTYPE_IP, ip_handle);
-	dissector_add("fr.ietf", NLPID_IP, ip_handle);
-	dissector_add("x.25.spi", NLPID_IP, ip_handle);
-        dissector_add("arcnet.protocol_id", ARCNET_PROTO_IP_1051, ip_handle);
-        dissector_add("arcnet.protocol_id", ARCNET_PROTO_IP_1201, ip_handle);
+//	dissector_add("null.type", BSD_AF_INET, ip_handle);
+//	dissector_add("chdlctype", ETHERTYPE_IP, ip_handle);
+//	dissector_add("fr.ietf", NLPID_IP, ip_handle);
+//	dissector_add("x.25.spi", NLPID_IP, ip_handle);
+//       dissector_add("arcnet.protocol_id", ARCNET_PROTO_IP_1051, ip_handle);
+//        dissector_add("arcnet.protocol_id", ARCNET_PROTO_IP_1201, ip_handle);
 }
 
 void
@@ -1764,11 +1766,11 @@
 
     { &hf_icmp_type,
       { "Type",		"icmp.type",		FT_UINT8, BASE_DEC,	NULL, 0x0,
-      	"", HFILL }},
+      	"", SQLFILL }},
 
     { &hf_icmp_code,
       { "Code",		"icmp.code",		FT_UINT8, BASE_HEX,	NULL, 0x0,
-      	"", HFILL }},
+      	"", SQLFILL }},
 
     { &hf_icmp_checksum,
       { "Checksum",	"icmp.checksum",	FT_UINT16, BASE_HEX,	NULL, 0x0,
@@ -1870,6 +1872,7 @@
 
   proto_icmp = proto_register_protocol("Internet Control Message Protocol",
 				       "ICMP", "icmp");
+  proto_register_sql_protocol(proto_icmp);
   proto_register_field_array(proto_icmp, hf, array_length(hf));
   proto_register_subtree_array(ett, array_length(ett));
 }
diff -Naur ethereal-0.9.16/packet-pop.c ethereal-0.9.16_new/packet-pop.c
--- ethereal-0.9.16/packet-pop.c	2003-06-12 09:53:40.000000000 +1000
+++ ethereal-0.9.16_new/packet-pop.c	2003-11-26 19:27:45.000000000 +1100
@@ -39,6 +39,10 @@
 static int proto_pop = -1;
 static int hf_pop_response = -1;
 static int hf_pop_request = -1;
+static int hf_pop_req_command = -1;
+static int hf_pop_req_parameter = -1;
+static int hf_pop_rsp = -1;
+static int hf_pop_rsp_parameter = -1;
 
 static gint ett_pop = -1;
 static gint ett_pop_reqresp = -1;
@@ -113,11 +117,27 @@
 		}
 
 		if (is_request) {
+			gint next_offset;
+                                                    gint space_offset = tvb_find_guint8(tvb,0,-1,' ');
+			gint line_offset =tvb_find_line_end(tvb,0,-1,&next_offset,FALSE);
+
 			proto_tree_add_boolean_hidden(pop_tree,
-			    hf_pop_request, tvb, 0, 0, TRUE);
-		} else {
+			    hf_pop_request, tvb, 0, 0, TRUE); 
+ 			proto_tree_add_item(pop_tree, hf_pop_req_command, tvb,
+				  0 , space_offset, FALSE);
+			proto_tree_add_item(pop_tree, hf_pop_req_parameter, tvb,
+				  space_offset+1,line_offset-space_offset-1, FALSE);
+		} else {    
+			gint next_offset;
+		                  int space_offset = tvb_find_guint8(tvb,0,-1,' ');
+			 int line_offset =tvb_find_line_end(tvb,0,-1,&next_offset,FALSE);
+
 			proto_tree_add_boolean_hidden(pop_tree,
 			    hf_pop_response, tvb, 0, 0, TRUE);
+			proto_tree_add_item(pop_tree, hf_pop_rsp, tvb,
+				  0 , space_offset, FALSE);
+			proto_tree_add_item(pop_tree, hf_pop_rsp_parameter, tvb,
+				  space_offset+1,line_offset-space_offset-1, FALSE);
 		}
 
 		/*
@@ -211,14 +231,30 @@
     { &hf_pop_request,
       { "Request",            "pop.request",
 	FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-      	"TRUE if POP request", HFILL }}
+      	"TRUE if POP request", HFILL }},
+    { &hf_pop_req_command,
+      { "Command", "pop.req.command", FT_STRING,  BASE_NONE, NULL, 0x0,
+      	"", SQLFILL }},
+
+    { &hf_pop_req_parameter,
+      { "Request parameter", "pop.req.parameter", FT_STRING, BASE_NONE, NULL, 0x0,
+      	"", SQLFILL }},
+
+    { &hf_pop_rsp,
+      { "Response code", "pop.rsp", FT_STRING, BASE_NONE, NULL, 0x0,
+      	"", SQLFILL }},
+
+    { &hf_pop_rsp_parameter,
+      { "Response parameter", "pop.rsp.parameter", FT_STRING, BASE_NONE, NULL, 0x0,
+      	"", SQLFILL }}
   };
   static gint *ett[] = {
     &ett_pop,
     &ett_pop_reqresp,
   };
 
-  proto_pop = proto_register_protocol("Post Office Protocol", "POP", "pop");
+  proto_pop = proto_register_protocol("Post Office Protocol", "POP", "pop"); 
+  proto_register_sql_protocol(proto_pop);
   proto_register_field_array(proto_pop, hf, array_length(hf));
   proto_register_subtree_array(ett, array_length(ett));
 }
diff -Naur ethereal-0.9.16/packet-smtp.c ethereal-0.9.16_new/packet-smtp.c
--- ethereal-0.9.16/packet-smtp.c	2003-09-19 10:51:09.000000000 +1000
+++ ethereal-0.9.16_new/packet-smtp.c	2003-11-26 19:27:45.000000000 +1100
@@ -501,7 +501,7 @@
 	   */
 	  line = tvb_get_ptr(tvb, offset, linelen);
 	  if (linelen >= 3 && isdigit(line[0]) && isdigit(line[1])
-	 		   && isdigit(line[2])) {
+	 		   && isdigit(line[2]) && isspace(line[3])) {
 	    /*
 	     * We have a 3-digit response code.
 	     */
@@ -546,19 +546,19 @@
 
     { &hf_smtp_req_command,
       { "Command", "smtp.req.command", FT_STRING,  BASE_NONE, NULL, 0x0,
-      	"", HFILL }},
+      	"", SQLFILL }},
 
     { &hf_smtp_req_parameter,
       { "Request parameter", "smtp.req.parameter", FT_STRING, BASE_NONE, NULL, 0x0,
-      	"", HFILL }},
+      	"", SQLFILL }},
 
     { &hf_smtp_rsp_code,
       { "Response code", "smtp.response.code", FT_UINT32, BASE_DEC, NULL, 0x0,
-      	"", HFILL }},
+      	"", SQLFILL }},
 
     { &hf_smtp_rsp_parameter,
       { "Response parameter", "smtp.rsp.parameter", FT_STRING, BASE_NONE, NULL, 0x0,
-      	"", HFILL }}
+      	"", SQLFILL }}
   };
   static gint *ett[] = {
     &ett_smtp,
@@ -570,7 +570,7 @@
 
   proto_smtp = proto_register_protocol("Simple Mail Transfer Protocol",
 				       "SMTP", "smtp");
-
+  proto_register_sql_protocol(proto_smtp);
   proto_register_field_array(proto_smtp, hf, array_length(hf));
   proto_register_subtree_array(ett, array_length(ett));
   register_init_routine(&smtp_init_protocol);
diff -Naur ethereal-0.9.16/packet-tcp.c ethereal-0.9.16_new/packet-tcp.c
--- ethereal-0.9.16/packet-tcp.c	2003-11-03 04:15:21.000000000 +1100
+++ ethereal-0.9.16_new/packet-tcp.c	2003-11-26 19:27:45.000000000 +1100
@@ -2727,11 +2727,11 @@
 
 		{ &hf_tcp_srcport,
 		{ "Source Port",		"tcp.srcport", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_dstport,
 		{ "Destination Port",		"tcp.dstport", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_port,
 		{ "Source or Destination Port",	"tcp.port", FT_UINT16, BASE_DEC, NULL, 0x0,
@@ -2739,23 +2739,23 @@
 
 		{ &hf_tcp_seq,
 		{ "Sequence number",		"tcp.seq", FT_UINT32, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_nxtseq,
 		{ "Next sequence number",	"tcp.nxtseq", FT_UINT32, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_ack,
 		{ "Acknowledgement number",	"tcp.ack", FT_UINT32, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_hdr_len,
 		{ "Header Length",		"tcp.hdr_len", FT_UINT8, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_flags,
 		{ "Flags",			"tcp.flags", FT_UINT8, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_flags_cwr,
 		{ "Congestion Window Reduced (CWR)",			"tcp.flags.cwr", FT_BOOLEAN, 8, TFS(&flags_set_truth), TH_CWR,
@@ -2792,15 +2792,15 @@
 		/* 32 bits so we can present some values adjusted to window scaling */
 		{ &hf_tcp_window_size,
 		{ "Window size",		"tcp.window_size", FT_UINT32, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_checksum,
 		{ "Checksum",			"tcp.checksum", FT_UINT16, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_checksum_bad,
 		{ "Bad Checksum",		"tcp.checksum_bad", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_analysis_flags,
 		{ "TCP Analysis Flags",		"tcp.analysis.flags", FT_NONE, BASE_NONE, NULL, 0x0,
@@ -2860,7 +2860,7 @@
 
 		{ &hf_tcp_len,
 		  { "TCP Segment Len",            "tcp.len", FT_UINT32, BASE_DEC, NULL, 0x0,
-		    "", HFILL}},
+		    "", SQLFILL}},
 
 		{ &hf_tcp_analysis_acks_frame,
 		  { "This is an ACK to the segment in frame",            "tcp.analysis.acks_frame", FT_FRAMENUM, BASE_NONE, NULL, 0x0,
@@ -2872,7 +2872,7 @@
 
 		{ &hf_tcp_urgent_pointer,
 		{ "Urgent pointer",		"tcp.urgent_pointer", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_tcp_segment_overlap,
 		{ "Segment overlap",	"tcp.segment.overlap", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
@@ -2985,6 +2985,7 @@
 
 	proto_tcp = proto_register_protocol("Transmission Control Protocol",
 	    "TCP", "tcp");
+	proto_register_sql_protocol(proto_tcp);
 	proto_register_field_array(proto_tcp, hf, array_length(hf));
 	proto_register_subtree_array(ett, array_length(ett));
 
diff -Naur ethereal-0.9.16/packet-udp.c ethereal-0.9.16_new/packet-udp.c
--- ethereal-0.9.16/packet-udp.c	2003-09-05 12:10:05.000000000 +1000
+++ ethereal-0.9.16_new/packet-udp.c	2003-11-26 19:27:45.000000000 +1100
@@ -276,11 +276,11 @@
 	static hf_register_info hf[] = {
 		{ &hf_udp_srcport,
 		{ "Source Port",	"udp.srcport", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_udp_dstport,
 		{ "Destination Port",	"udp.dstport", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_udp_port,
 		{ "Source or Destination Port",	"udp.port", FT_UINT16, BASE_DEC,  NULL, 0x0,
@@ -288,15 +288,15 @@
 
 		{ &hf_udp_length,
 		{ "Length",		"udp.length", FT_UINT16, BASE_DEC, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_udp_checksum_bad,
 		{ "Bad Checksum",	"udp.checksum_bad", FT_BOOLEAN, BASE_NONE, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 
 		{ &hf_udp_checksum,
 		{ "Checksum",		"udp.checksum", FT_UINT16, BASE_HEX, NULL, 0x0,
-			"", HFILL }},
+			"", SQLFILL }},
 	};
 	static gint *ett[] = {
 		&ett_udp,
@@ -304,6 +304,7 @@
 
 	proto_udp = proto_register_protocol("User Datagram Protocol",
 	    "UDP", "udp");
+	proto_register_sql_protocol(proto_udp);
 	proto_register_field_array(proto_udp, hf, array_length(hf));
 	proto_register_subtree_array(ett, array_length(ett));
 
diff -Naur ethereal-0.9.16/print.c ethereal-0.9.16_new/print.c
--- ethereal-0.9.16/print.c	2002-08-29 10:40:05.000000000 +1000
+++ ethereal-0.9.16_new/print.c	2003-11-26 19:27:45.000000000 +1100
@@ -40,6 +40,10 @@
 #include "ps.h"
 #include "util.h"
 #include "packet-data.h"
+#include "sql.h"
+
+gboolean print_sql;               //Shall we emit sql statements?
+gboolean print_knowledge;  //Shall we emit knowledgebase statements?
 
 static void proto_tree_print_node(GNode *node, gpointer data);
 static void print_hex_data_buffer(FILE *fh, register const guchar *cp,
@@ -83,7 +87,7 @@
     FILE *fh)
 {
 	print_data data;
-
+ 
 	/* Create the output */
 	data.level = 0;
 	data.fh = fh;
@@ -136,26 +140,40 @@
 	print_data	*pdata = (print_data*) data;
 	const guint8	*pd;
 	gchar		label_str[ITEM_LABEL_LENGTH];
-	gchar		*label_ptr;
 
 	/* Don't print invisible entries. */
-	if (!fi->visible)
-		return;
-
-	/* was a free format label produced? */
-	if (fi->representation) {
-		label_ptr = fi->representation;
-	}
-	else { /* no, make a generic label */
-		label_ptr = label_str;
-		proto_item_fill_label(fi, label_str);
-	}
-
-	print_line(pdata->fh, pdata->level, pdata->format, label_ptr);
+	if (!fi->visible) return;
+	
+	/* SQL stuff */
+	if(fi->hfinfo->sql==2) {
+	  if(fi->hfinfo->type == FT_PROTOCOL) {
+	    //Add a new protocol:
+	    if(!strcasecmp(fi->hfinfo->abbrev,"frame")) {
+	      if(print_sql) print_sql_from_dissection();
+	      if(print_knowledge) make_deductions();
+	      delete_protocols();
+	      frame_no++;
+	    };
+	    
+	    add_protocol(fi->hfinfo->abbrev);
+	    /*	    if(additional_sql && print_sql) {
+	      printf("%s",additional_sql->str);
+	      g_string_free(additional_sql,1);
+	      additional_sql=g_string_new("");
+	    } else additional_sql=g_string_new("");
+	    */
+	  } else {
+	    //	    char *temp_string = (char *)malloc(ITEM_LABEL_LENGTH*sizeof(char));
+	    
+	    //assert(temp_string != NULL); 
+	    //proto_item_fill_sql_label(fi, temp_string);
+	    add_field(fi->hfinfo->abbrev,fi);
+	  };
+	};
 
 	/* If it's uninterpreted data, dump it (unless our caller will
 	   be printing the entire packet in hex). */
-	if (fi->hfinfo->id == proto_data && pdata->print_hex_for_data) {
+	if (!print_sql &&!print_knowledge && fi->hfinfo->id == proto_data && pdata->print_hex_for_data) {
 		/*
 		 * Find the data for this field.
 		 */
@@ -190,6 +208,7 @@
 	const guchar *cp;
 	guint length;
 
+	printf("Printing hex data\n");
 	/*
 	 * Set "multiple_sources" iff this frame has more than one
 	 * data source; if it does, we need to print the name of
diff -Naur ethereal-0.9.16/register.c ethereal-0.9.16_new/register.c
--- ethereal-0.9.16/register.c	2003-11-04 10:32:14.000000000 +1100
+++ ethereal-0.9.16_new/register.c	2003-11-26 19:27:45.000000000 +1100
@@ -2,798 +2,29 @@
 /* It is created automatically by the Makefile.  */
 #include "register.h"
 void register_all_protocols(void) {
-  {extern void proto_register_aarp (void); proto_register_aarp ();}
-  {extern void proto_register_acap (void); proto_register_acap ();}
-  {extern void proto_register_afp (void); proto_register_afp ();}
-  {extern void proto_register_afs (void); proto_register_afs ();}
-  {extern void proto_register_afs4int (void); proto_register_afs4int ();}
-  {extern void proto_register_aim (void); proto_register_aim ();}
-  {extern void proto_register_ajp13 (void); proto_register_ajp13 ();}
-  {extern void proto_register_alcap (void); proto_register_alcap ();}
-  {extern void proto_register_ans (void); proto_register_ans ();}
-  {extern void proto_register_ansi_637 (void); proto_register_ansi_637 ();}
-  {extern void proto_register_ansi_683 (void); proto_register_ansi_683 ();}
-  {extern void proto_register_ansi_a (void); proto_register_ansi_a ();}
-  {extern void proto_register_ansi_map (void); proto_register_ansi_map ();}
-  {extern void proto_register_aodv (void); proto_register_aodv ();}
-  {extern void proto_register_arcnet (void); proto_register_arcnet ();}
-  {extern void proto_register_arp (void); proto_register_arp ();}
-  {extern void proto_register_asap (void); proto_register_asap ();}
-  {extern void proto_register_ascend (void); proto_register_ascend ();}
-  {extern void proto_register_asf (void); proto_register_asf ();}
-  {extern void proto_register_atalk (void); proto_register_atalk ();}
-  {extern void proto_register_atm (void); proto_register_atm ();}
-  {extern void proto_register_auto_rp (void); proto_register_auto_rp ();}
-  {extern void proto_register_bacapp (void); proto_register_bacapp ();}
-  {extern void proto_register_bacnet (void); proto_register_bacnet ();}
-  {extern void proto_register_bacp (void); proto_register_bacp ();}
-  {extern void proto_register_bap (void); proto_register_bap ();}
-  {extern void proto_register_beep (void); proto_register_beep ();}
-  {extern void proto_register_bgp (void); proto_register_bgp ();}
-  {extern void proto_register_bicc (void); proto_register_bicc ();}
-  {extern void proto_register_bofl (void); proto_register_bofl ();}
-  {extern void proto_register_bootp (void); proto_register_bootp ();}
-  {extern void proto_register_bootparams (void); proto_register_bootparams ();}
-  {extern void proto_register_bossvr (void); proto_register_bossvr ();}
-  {extern void proto_register_bpdu (void); proto_register_bpdu ();}
-  {extern void proto_register_brdwlk (void); proto_register_brdwlk ();}
-  {extern void proto_register_bssap (void); proto_register_bssap ();}
-  {extern void proto_register_bssgp (void); proto_register_bssgp ();}
-  {extern void proto_register_butc (void); proto_register_butc ();}
-  {extern void proto_register_bvlc (void); proto_register_bvlc ();}
-  {extern void proto_register_cbcp (void); proto_register_cbcp ();}
-  {extern void proto_register_ccp (void); proto_register_ccp ();}
-  {extern void proto_register_cdp (void); proto_register_cdp ();}
-  {extern void proto_register_cdpcp (void); proto_register_cdpcp ();}
-  {extern void proto_register_cds_clerkserver (void); proto_register_cds_clerkserver ();}
-  {extern void proto_register_cds_solicit (void); proto_register_cds_solicit ();}
-  {extern void proto_register_cgmp (void); proto_register_cgmp ();}
-  {extern void proto_register_chap (void); proto_register_chap ();}
-  {extern void proto_register_chdlc (void); proto_register_chdlc ();}
-  {extern void proto_register_cipencap (void); proto_register_cipencap ();}
-  {extern void proto_register_cisco_oui (void); proto_register_cisco_oui ();}
-  {extern void proto_register_clearcase (void); proto_register_clearcase ();}
-  {extern void proto_register_clip (void); proto_register_clip ();}
-  {extern void proto_register_clnp (void); proto_register_clnp ();}
-  {extern void proto_register_cltp (void); proto_register_cltp ();}
-  {extern void proto_register_comp_data (void); proto_register_comp_data ();}
-  {extern void proto_register_conv (void); proto_register_conv ();}
-  {extern void proto_register_cops (void); proto_register_cops ();}
-  {extern void proto_register_cosine (void); proto_register_cosine ();}
-  {extern void proto_register_cotp (void); proto_register_cotp ();}
-  {extern void proto_register_cpha (void); proto_register_cpha ();}
-  {extern void proto_register_cprpc_server (void); proto_register_cprpc_server ();}
-  {extern void proto_register_cups (void); proto_register_cups ();}
   {extern void proto_register_data (void); proto_register_data ();}
-  {extern void proto_register_dccp (void); proto_register_dccp ();}
-  {extern void proto_register_dce_update (void); proto_register_dce_update ();}
-  {extern void proto_register_dcerpc (void); proto_register_dcerpc ();}
-  {extern void proto_register_dcerpc_atsvc (void); proto_register_dcerpc_atsvc ();}
-  {extern void proto_register_dcerpc_browser (void); proto_register_dcerpc_browser ();}
-  {extern void proto_register_dcerpc_dfs (void); proto_register_dcerpc_dfs ();}
-  {extern void proto_register_dcerpc_dnsserver (void); proto_register_dcerpc_dnsserver ();}
-  {extern void proto_register_dcerpc_drsuapi (void); proto_register_dcerpc_drsuapi ();}
-  {extern void proto_register_dcerpc_initshutdown (void); proto_register_dcerpc_initshutdown ();}
-  {extern void proto_register_dcerpc_lsa (void); proto_register_dcerpc_lsa ();}
-  {extern void proto_register_dcerpc_lsa_ds (void); proto_register_dcerpc_lsa_ds ();}
-  {extern void proto_register_dcerpc_mapi (void); proto_register_dcerpc_mapi ();}
-  {extern void proto_register_dcerpc_messenger (void); proto_register_dcerpc_messenger ();}
-  {extern void proto_register_dcerpc_netlogon (void); proto_register_dcerpc_netlogon ();}
-  {extern void proto_register_dcerpc_reg (void); proto_register_dcerpc_reg ();}
-  {extern void proto_register_dcerpc_samr (void); proto_register_dcerpc_samr ();}
-  {extern void proto_register_dcerpc_spoolss (void); proto_register_dcerpc_spoolss ();}
-  {extern void proto_register_dcerpc_srvsvc (void); proto_register_dcerpc_srvsvc ();}
-  {extern void proto_register_dcerpc_svcctl (void); proto_register_dcerpc_svcctl ();}
-  {extern void proto_register_dcerpc_tapi (void); proto_register_dcerpc_tapi ();}
-  {extern void proto_register_dcerpc_wkssvc (void); proto_register_dcerpc_wkssvc ();}
-  {extern void proto_register_ddtp (void); proto_register_ddtp ();}
-  {extern void proto_register_dec_bpdu (void); proto_register_dec_bpdu ();}
-  {extern void proto_register_dhcpv6 (void); proto_register_dhcpv6 ();}
-  {extern void proto_register_diameter (void); proto_register_diameter ();}
-  {extern void proto_register_distcc (void); proto_register_distcc ();}
-  {extern void proto_register_dlsw (void); proto_register_dlsw ();}
   {extern void proto_register_dns (void); proto_register_dns ();}
-  {extern void proto_register_dsi (void); proto_register_dsi ();}
-  {extern void proto_register_dtsprovider (void); proto_register_dtsprovider ();}
-  {extern void proto_register_dtsstime_req (void); proto_register_dtsstime_req ();}
-  {extern void proto_register_dvmrp (void); proto_register_dvmrp ();}
-  {extern void proto_register_eap (void); proto_register_eap ();}
-  {extern void proto_register_eapol (void); proto_register_eapol ();}
-  {extern void proto_register_echo (void); proto_register_echo ();}
-  {extern void proto_register_edonkey (void); proto_register_edonkey ();}
-  {extern void proto_register_eigrp (void); proto_register_eigrp ();}
-  {extern void proto_register_enc (void); proto_register_enc ();}
-  {extern void proto_register_epm (void); proto_register_epm ();}
-  {extern void proto_register_esis (void); proto_register_esis ();}
   {extern void proto_register_eth (void); proto_register_eth ();}
-  {extern void proto_register_etherip (void); proto_register_etherip ();}
   {extern void proto_register_ethertype (void); proto_register_ethertype ();}
-  {extern void proto_register_fc (void); proto_register_fc ();}
-  {extern void proto_register_fcct (void); proto_register_fcct ();}
-  {extern void proto_register_fcdns (void); proto_register_fcdns ();}
-  {extern void proto_register_fcels (void); proto_register_fcels ();}
-  {extern void proto_register_fcfcs (void); proto_register_fcfcs ();}
-  {extern void proto_register_fcfzs (void); proto_register_fcfzs ();}
-  {extern void proto_register_fcip (void); proto_register_fcip ();}
-  {extern void proto_register_fcp (void); proto_register_fcp ();}
-  {extern void proto_register_fcsbccs (void); proto_register_fcsbccs ();}
-  {extern void proto_register_fcsp (void); proto_register_fcsp ();}
-  {extern void proto_register_fcswils (void); proto_register_fcswils ();}
-  {extern void proto_register_fddi (void); proto_register_fddi ();}
-  {extern void proto_register_fix (void); proto_register_fix ();}
-  {extern void proto_register_fldb (void); proto_register_fldb ();}
-  {extern void proto_register_fr (void); proto_register_fr ();}
   {extern void proto_register_frame (void); proto_register_frame ();}
-  {extern void proto_register_ftp (void); proto_register_ftp ();}
-  {extern void proto_register_ftserver (void); proto_register_ftserver ();}
-  {extern void proto_register_fw1 (void); proto_register_fw1 ();}
-  {extern void proto_register_giop (void); proto_register_giop ();}
-  {extern void proto_register_gmrp (void); proto_register_gmrp ();}
-  {extern void proto_register_gnutella (void); proto_register_gnutella ();}
-  {extern void proto_register_gprs_ns (void); proto_register_gprs_ns ();}
-  {extern void proto_register_gre (void); proto_register_gre ();}
-  {extern void proto_register_gsm_a (void); proto_register_gsm_a ();}
-  {extern void proto_register_gsm_sms (void); proto_register_gsm_sms ();}
-  {extern void proto_register_gssapi (void); proto_register_gssapi ();}
-  {extern void proto_register_gtp (void); proto_register_gtp ();}
-  {extern void proto_register_gvrp (void); proto_register_gvrp ();}
-  {extern void proto_register_h1 (void); proto_register_h1 ();}
-  {extern void proto_register_h225 (void); proto_register_h225 ();}
-  {extern void proto_register_h245 (void); proto_register_h245 ();}
-  {extern void proto_register_h261 (void); proto_register_h261 ();}
-  {extern void proto_register_h263 (void); proto_register_h263 ();}
-  {extern void proto_register_h4501 (void); proto_register_h4501 ();}
-  {extern void proto_register_hclnfsd (void); proto_register_hclnfsd ();}
-  {extern void proto_register_hpext (void); proto_register_hpext ();}
-  {extern void proto_register_hsrp (void); proto_register_hsrp ();}
   {extern void proto_register_http (void); proto_register_http ();}
-  {extern void proto_register_hyperscsi (void); proto_register_hyperscsi ();}
-  {extern void proto_register_iapp (void); proto_register_iapp ();}
-  {extern void proto_register_ib (void); proto_register_ib ();}
-  {extern void proto_register_icap (void); proto_register_icap ();}
   {extern void proto_register_icmp (void); proto_register_icmp ();}
-  {extern void proto_register_icmpv6 (void); proto_register_icmpv6 ();}
-  {extern void proto_register_icp (void); proto_register_icp ();}
-  {extern void proto_register_icq (void); proto_register_icq ();}
-  {extern void proto_register_ieee80211 (void); proto_register_ieee80211 ();}
-  {extern void proto_register_igmp (void); proto_register_igmp ();}
-  {extern void proto_register_igrp (void); proto_register_igrp ();}
-  {extern void proto_register_imap (void); proto_register_imap ();}
   {extern void proto_register_ip (void); proto_register_ip ();}
-  {extern void proto_register_ipcp (void); proto_register_ipcp ();}
-  {extern void proto_register_ipfc (void); proto_register_ipfc ();}
-  {extern void proto_register_ipmi (void); proto_register_ipmi ();}
-  {extern void proto_register_ipp (void); proto_register_ipp ();}
-  {extern void proto_register_ipsec (void); proto_register_ipsec ();}
-  {extern void proto_register_ipv6 (void); proto_register_ipv6 ();}
-  {extern void proto_register_ipv6cp (void); proto_register_ipv6cp ();}
-  {extern void proto_register_ipx (void); proto_register_ipx ();}
-  {extern void proto_register_ipxwan (void); proto_register_ipxwan ();}
-  {extern void proto_register_irc (void); proto_register_irc ();}
-  {extern void proto_register_isakmp (void); proto_register_isakmp ();}
-  {extern void proto_register_iscsi (void); proto_register_iscsi ();}
-  {extern void proto_register_isdn (void); proto_register_isdn ();}
-  {extern void proto_register_isis (void); proto_register_isis ();}
-  {extern void proto_register_isl (void); proto_register_isl ();}
-  {extern void proto_register_isns (void); proto_register_isns ();}
-  {extern void proto_register_isup (void); proto_register_isup ();}
-  {extern void proto_register_iua (void); proto_register_iua ();}
-  {extern void proto_register_jabber (void); proto_register_jabber ();}
-  {extern void proto_register_kadm5 (void); proto_register_kadm5 ();}
-  {extern void proto_register_kerberos (void); proto_register_kerberos ();}
-  {extern void proto_register_klm (void); proto_register_klm ();}
-  {extern void proto_register_krb5rpc (void); proto_register_krb5rpc ();}
-  {extern void proto_register_l2tp (void); proto_register_l2tp ();}
-  {extern void proto_register_lacpdu (void); proto_register_lacpdu ();}
-  {extern void proto_register_lapb (void); proto_register_lapb ();}
-  {extern void proto_register_lapbether (void); proto_register_lapbether ();}
-  {extern void proto_register_lapd (void); proto_register_lapd ();}
-  {extern void proto_register_laplink (void); proto_register_laplink ();}
-  {extern void proto_register_lcp (void); proto_register_lcp ();}
-  {extern void proto_register_ldap (void); proto_register_ldap ();}
-  {extern void proto_register_ldp (void); proto_register_ldp ();}
-  {extern void proto_register_llc (void); proto_register_llc ();}
-  {extern void proto_register_lmi (void); proto_register_lmi ();}
-  {extern void proto_register_lmp (void); proto_register_lmp ();}
-  {extern void proto_register_lpd (void); proto_register_lpd ();}
-  {extern void proto_register_lwapp (void); proto_register_lwapp ();}
-  {extern void proto_register_m2pa (void); proto_register_m2pa ();}
-  {extern void proto_register_m2tp (void); proto_register_m2tp ();}
-  {extern void proto_register_m2ua (void); proto_register_m2ua ();}
-  {extern void proto_register_m3ua (void); proto_register_m3ua ();}
-  {extern void proto_register_mdshdr (void); proto_register_mdshdr ();}
-  {extern void proto_register_mgmt (void); proto_register_mgmt ();}
-  {extern void proto_register_mip (void); proto_register_mip ();}
-  {extern void proto_register_mip6 (void); proto_register_mip6 ();}
-  {extern void proto_register_mmse (void); proto_register_mmse ();}
-  {extern void proto_register_modbus (void); proto_register_modbus ();}
-  {extern void proto_register_mount (void); proto_register_mount ();}
-  {extern void proto_register_mp (void); proto_register_mp ();}
-  {extern void proto_register_mpeg1 (void); proto_register_mpeg1 ();}
-  {extern void proto_register_mpls (void); proto_register_mpls ();}
-  {extern void proto_register_mplscp (void); proto_register_mplscp ();}
-  {extern void proto_register_mrdisc (void); proto_register_mrdisc ();}
-  {extern void proto_register_msdp (void); proto_register_msdp ();}
-  {extern void proto_register_msnip (void); proto_register_msnip ();}
-  {extern void proto_register_msnms (void); proto_register_msnms ();}
-  {extern void proto_register_msproxy (void); proto_register_msproxy ();}
-  {extern void proto_register_mtp2 (void); proto_register_mtp2 ();}
-  {extern void proto_register_mtp3 (void); proto_register_mtp3 ();}
-  {extern void proto_register_mtp3mg (void); proto_register_mtp3mg ();}
-  {extern void proto_register_mysql (void); proto_register_mysql ();}
-  {extern void proto_register_nbipx (void); proto_register_nbipx ();}
-  {extern void proto_register_nbt (void); proto_register_nbt ();}
-  {extern void proto_register_ncp (void); proto_register_ncp ();}
-  {extern void proto_register_ncp2222 (void); proto_register_ncp2222 ();}
-  {extern void proto_register_ndmp (void); proto_register_ndmp ();}
-  {extern void proto_register_ndps (void); proto_register_ndps ();}
-  {extern void proto_register_netbios (void); proto_register_netbios ();}
-  {extern void proto_register_netflow (void); proto_register_netflow ();}
-  {extern void proto_register_netlib (void); proto_register_netlib ();}
-  {extern void proto_register_nfs (void); proto_register_nfs ();}
-  {extern void proto_register_nfsacl (void); proto_register_nfsacl ();}
-  {extern void proto_register_nfsauth (void); proto_register_nfsauth ();}
-  {extern void proto_register_nis (void); proto_register_nis ();}
-  {extern void proto_register_niscb (void); proto_register_niscb ();}
-  {extern void proto_register_nlm (void); proto_register_nlm ();}
-  {extern void proto_register_nlsp (void); proto_register_nlsp ();}
-  {extern void proto_register_nmpi (void); proto_register_nmpi ();}
-  {extern void proto_register_nntp (void); proto_register_nntp ();}
-  {extern void proto_register_nortel_oui (void); proto_register_nortel_oui ();}
-  {extern void proto_register_nspi (void); proto_register_nspi ();}
-  {extern void proto_register_ntlmssp (void); proto_register_ntlmssp ();}
-  {extern void proto_register_ntp (void); proto_register_ntp ();}
-  {extern void proto_register_null (void); proto_register_null ();}
-  {extern void proto_register_old_pflog (void); proto_register_old_pflog ();}
-  {extern void proto_register_osi (void); proto_register_osi ();}
-  {extern void proto_register_osi_options (void); proto_register_osi_options ();}
-  {extern void proto_register_ospf (void); proto_register_ospf ();}
-  {extern void proto_register_oxid (void); proto_register_oxid ();}
-  {extern void proto_register_pap (void); proto_register_pap ();}
-  {extern void proto_register_pcnfsd (void); proto_register_pcnfsd ();}
-  {extern void proto_register_per (void); proto_register_per ();}
-  {extern void proto_register_pflog (void); proto_register_pflog ();}
-  {extern void proto_register_pgm (void); proto_register_pgm ();}
-  {extern void proto_register_pim (void); proto_register_pim ();}
-  {extern void proto_register_pipe_dcerpc (void); proto_register_pipe_dcerpc ();}
-  {extern void proto_register_pipe_lanman (void); proto_register_pipe_lanman ();}
   {extern void proto_register_pop (void); proto_register_pop ();}
-  {extern void proto_register_portmap (void); proto_register_portmap ();}
-  {extern void proto_register_ppp (void); proto_register_ppp ();}
-  {extern void proto_register_pppmux (void); proto_register_pppmux ();}
-  {extern void proto_register_pppmuxcp (void); proto_register_pppmuxcp ();}
-  {extern void proto_register_pppoed (void); proto_register_pppoed ();}
-  {extern void proto_register_pppoes (void); proto_register_pppoes ();}
-  {extern void proto_register_pptp (void); proto_register_pptp ();}
-  {extern void proto_register_prism (void); proto_register_prism ();}
-  {extern void proto_register_q2931 (void); proto_register_q2931 ();}
-  {extern void proto_register_q931 (void); proto_register_q931 ();}
-  {extern void proto_register_q933 (void); proto_register_q933 ();}
-  {extern void proto_register_qllc (void); proto_register_qllc ();}
-  {extern void proto_register_quake (void); proto_register_quake ();}
-  {extern void proto_register_quake2 (void); proto_register_quake2 ();}
-  {extern void proto_register_quake3 (void); proto_register_quake3 ();}
-  {extern void proto_register_quakeworld (void); proto_register_quakeworld ();}
-  {extern void proto_register_radius (void); proto_register_radius ();}
-  {extern void proto_register_ranap (void); proto_register_ranap ();}
-  {extern void proto_register_raw (void); proto_register_raw ();}
-  {extern void proto_register_remact (void); proto_register_remact ();}
-  {extern void proto_register_rep_proc (void); proto_register_rep_proc ();}
-  {extern void proto_register_rip (void); proto_register_rip ();}
-  {extern void proto_register_ripng (void); proto_register_ripng ();}
-  {extern void proto_register_rlogin (void); proto_register_rlogin ();}
-  {extern void proto_register_rmcp (void); proto_register_rmcp ();}
-  {extern void proto_register_rmi (void); proto_register_rmi ();}
-  {extern void proto_register_rmp (void); proto_register_rmp ();}
-  {extern void proto_register_roverride (void); proto_register_roverride ();}
-  {extern void proto_register_rpc (void); proto_register_rpc ();}
-  {extern void proto_register_rpl (void); proto_register_rpl ();}
-  {extern void proto_register_rpriv (void); proto_register_rpriv ();}
-  {extern void proto_register_rquota (void); proto_register_rquota ();}
-  {extern void proto_register_rs_acct (void); proto_register_rs_acct ();}
-  {extern void proto_register_rs_attr (void); proto_register_rs_attr ();}
-  {extern void proto_register_rs_bind (void); proto_register_rs_bind ();}
-  {extern void proto_register_rs_misc (void); proto_register_rs_misc ();}
-  {extern void proto_register_rs_pgo (void); proto_register_rs_pgo ();}
-  {extern void proto_register_rs_repadm (void); proto_register_rs_repadm ();}
-  {extern void proto_register_rs_replist (void); proto_register_rs_replist ();}
-  {extern void proto_register_rs_unix (void); proto_register_rs_unix ();}
-  {extern void proto_register_rsec_login (void); proto_register_rsec_login ();}
-  {extern void proto_register_rsh (void); proto_register_rsh ();}
-  {extern void proto_register_rstat (void); proto_register_rstat ();}
-  {extern void proto_register_rsvp (void); proto_register_rsvp ();}
-  {extern void proto_register_rsync (void); proto_register_rsync ();}
-  {extern void proto_register_rtcp (void); proto_register_rtcp ();}
-  {extern void proto_register_rtp (void); proto_register_rtp ();}
-  {extern void proto_register_rtp_events (void); proto_register_rtp_events ();}
-  {extern void proto_register_rtsp (void); proto_register_rtsp ();}
-  {extern void proto_register_rwall (void); proto_register_rwall ();}
-  {extern void proto_register_rx (void); proto_register_rx ();}
-  {extern void proto_register_sadmind (void); proto_register_sadmind ();}
-  {extern void proto_register_sap (void); proto_register_sap ();}
-  {extern void proto_register_sccp (void); proto_register_sccp ();}
-  {extern void proto_register_sccpmg (void); proto_register_sccpmg ();}
-  {extern void proto_register_scsi (void); proto_register_scsi ();}
-  {extern void proto_register_sctp (void); proto_register_sctp ();}
-  {extern void proto_register_sdlc (void); proto_register_sdlc ();}
-  {extern void proto_register_sdp (void); proto_register_sdp ();}
-  {extern void proto_register_secidmap (void); proto_register_secidmap ();}
-  {extern void proto_register_sflow (void); proto_register_sflow ();}
-  {extern void proto_register_sip (void); proto_register_sip ();}
-  {extern void proto_register_skinny (void); proto_register_skinny ();}
-  {extern void proto_register_slarp (void); proto_register_slarp ();}
-  {extern void proto_register_slimp3 (void); proto_register_slimp3 ();}
-  {extern void proto_register_sll (void); proto_register_sll ();}
-  {extern void proto_register_smb (void); proto_register_smb ();}
-  {extern void proto_register_smb_browse (void); proto_register_smb_browse ();}
-  {extern void proto_register_smb_logon (void); proto_register_smb_logon ();}
-  {extern void proto_register_smb_mailslot (void); proto_register_smb_mailslot ();}
-  {extern void proto_register_smb_pipe (void); proto_register_smb_pipe ();}
-  {extern void proto_register_smb_sidsnooping (void); proto_register_smb_sidsnooping ();}
-  {extern void proto_register_smpp (void); proto_register_smpp ();}
   {extern void proto_register_smtp (void); proto_register_smtp ();}
-  {extern void proto_register_smux (void); proto_register_smux ();}
-  {extern void proto_register_sna (void); proto_register_sna ();}
-  {extern void proto_register_snaeth (void); proto_register_snaeth ();}
-  {extern void proto_register_snmp (void); proto_register_snmp ();}
-  {extern void proto_register_socks (void); proto_register_socks ();}
-  {extern void proto_register_sonmp (void); proto_register_sonmp ();}
-  {extern void proto_register_spnego (void); proto_register_spnego ();}
-  {extern void proto_register_spray (void); proto_register_spray ();}
-  {extern void proto_register_srvloc (void); proto_register_srvloc ();}
-  {extern void proto_register_sscop (void); proto_register_sscop ();}
-  {extern void proto_register_ssh (void); proto_register_ssh ();}
-  {extern void proto_register_ssl (void); proto_register_ssl ();}
-  {extern void proto_register_stat (void); proto_register_stat ();}
-  {extern void proto_register_statnotify (void); proto_register_statnotify ();}
-  {extern void proto_register_stun (void); proto_register_stun ();}
-  {extern void proto_register_sua (void); proto_register_sua ();}
-  {extern void proto_register_syslog (void); proto_register_syslog ();}
-  {extern void proto_register_t38 (void); proto_register_t38 ();}
-  {extern void proto_register_tacacs (void); proto_register_tacacs ();}
-  {extern void proto_register_tacplus (void); proto_register_tacplus ();}
-  {extern void proto_register_tcap (void); proto_register_tcap ();}
   {extern void proto_register_tcp (void); proto_register_tcp ();}
-  {extern void proto_register_telnet (void); proto_register_telnet ();}
-  {extern void proto_register_teredo (void); proto_register_teredo ();}
-  {extern void proto_register_tftp (void); proto_register_tftp ();}
-  {extern void proto_register_time (void); proto_register_time ();}
-  {extern void proto_register_tkn4int (void); proto_register_tkn4int ();}
-  {extern void proto_register_tns (void); proto_register_tns ();}
-  {extern void proto_register_tpcp (void); proto_register_tpcp ();}
-  {extern void proto_register_tpkt (void); proto_register_tpkt ();}
-  {extern void proto_register_tr (void); proto_register_tr ();}
-  {extern void proto_register_trmac (void); proto_register_trmac ();}
-  {extern void proto_register_tsp (void); proto_register_tsp ();}
-  {extern void proto_register_tzsp (void); proto_register_tzsp ();}
-  {extern void proto_register_ubikdisk (void); proto_register_ubikdisk ();}
-  {extern void proto_register_ubikvote (void); proto_register_ubikvote ();}
-  {extern void proto_register_ucp (void); proto_register_ucp ();}
   {extern void proto_register_udp (void); proto_register_udp ();}
-  {extern void proto_register_udpencap (void); proto_register_udpencap ();}
-  {extern void proto_register_v120 (void); proto_register_v120 ();}
-  {extern void proto_register_vines_arp (void); proto_register_vines_arp ();}
-  {extern void proto_register_vines_echo (void); proto_register_vines_echo ();}
-  {extern void proto_register_vines_frp (void); proto_register_vines_frp ();}
-  {extern void proto_register_vines_icp (void); proto_register_vines_icp ();}
-  {extern void proto_register_vines_ip (void); proto_register_vines_ip ();}
-  {extern void proto_register_vines_ipc (void); proto_register_vines_ipc ();}
-  {extern void proto_register_vines_llc (void); proto_register_vines_llc ();}
-  {extern void proto_register_vines_rtp (void); proto_register_vines_rtp ();}
-  {extern void proto_register_vines_spp (void); proto_register_vines_spp ();}
-  {extern void proto_register_vj (void); proto_register_vj ();}
-  {extern void proto_register_vlan (void); proto_register_vlan ();}
-  {extern void proto_register_vrrp (void); proto_register_vrrp ();}
-  {extern void proto_register_vtp (void); proto_register_vtp ();}
-  {extern void proto_register_wbxml (void); proto_register_wbxml ();}
-  {extern void proto_register_wccp (void); proto_register_wccp ();}
-  {extern void proto_register_wcp (void); proto_register_wcp ();}
-  {extern void proto_register_wfleet_hdlc (void); proto_register_wfleet_hdlc ();}
-  {extern void proto_register_who (void); proto_register_who ();}
-  {extern void proto_register_wlancap (void); proto_register_wlancap ();}
-  {extern void proto_register_wsp (void); proto_register_wsp ();}
-  {extern void proto_register_wtls (void); proto_register_wtls ();}
-  {extern void proto_register_wtp (void); proto_register_wtp ();}
-  {extern void proto_register_x11 (void); proto_register_x11 ();}
-  {extern void proto_register_x25 (void); proto_register_x25 ();}
-  {extern void proto_register_x29 (void); proto_register_x29 ();}
-  {extern void proto_register_xdmcp (void); proto_register_xdmcp ();}
-  {extern void proto_register_xot (void); proto_register_xot ();}
-  {extern void proto_register_xyplex (void); proto_register_xyplex ();}
-  {extern void proto_register_yhoo (void); proto_register_yhoo ();}
-  {extern void proto_register_ymsg (void); proto_register_ymsg ();}
-  {extern void proto_register_ypbind (void); proto_register_ypbind ();}
-  {extern void proto_register_yppasswd (void); proto_register_yppasswd ();}
-  {extern void proto_register_ypserv (void); proto_register_ypserv ();}
-  {extern void proto_register_ypxfr (void); proto_register_ypxfr ();}
-  {extern void proto_register_zebra (void); proto_register_zebra ();}
 }
 void register_all_protocol_handoffs(void) {
-  {extern void proto_reg_handoff_aarp (void); proto_reg_handoff_aarp ();}
-  {extern void proto_reg_handoff_acap (void); proto_reg_handoff_acap ();}
-  {extern void proto_reg_handoff_afp (void); proto_reg_handoff_afp ();}
-  {extern void proto_reg_handoff_afs4int (void); proto_reg_handoff_afs4int ();}
-  {extern void proto_reg_handoff_aim (void); proto_reg_handoff_aim ();}
-  {extern void proto_reg_handoff_ajp13 (void); proto_reg_handoff_ajp13 ();}
-  {extern void proto_reg_handoff_alcap (void); proto_reg_handoff_alcap ();}
-  {extern void proto_reg_handoff_ans (void); proto_reg_handoff_ans ();}
-  {extern void proto_reg_handoff_ansi_637 (void); proto_reg_handoff_ansi_637 ();}
-  {extern void proto_reg_handoff_ansi_683 (void); proto_reg_handoff_ansi_683 ();}
-  {extern void proto_reg_handoff_ansi_a (void); proto_reg_handoff_ansi_a ();}
-  {extern void proto_reg_handoff_ansi_map (void); proto_reg_handoff_ansi_map ();}
-  {extern void proto_reg_handoff_aodv (void); proto_reg_handoff_aodv ();}
-  {extern void proto_reg_handoff_arcnet (void); proto_reg_handoff_arcnet ();}
-  {extern void proto_reg_handoff_arp (void); proto_reg_handoff_arp ();}
-  {extern void proto_reg_handoff_asap (void); proto_reg_handoff_asap ();}
-  {extern void proto_reg_handoff_ascend (void); proto_reg_handoff_ascend ();}
-  {extern void proto_reg_handoff_asf (void); proto_reg_handoff_asf ();}
-  {extern void proto_reg_handoff_atalk (void); proto_reg_handoff_atalk ();}
-  {extern void proto_reg_handoff_atm (void); proto_reg_handoff_atm ();}
-  {extern void proto_reg_handoff_auto_rp (void); proto_reg_handoff_auto_rp ();}
-  {extern void proto_reg_handoff_bacapp (void); proto_reg_handoff_bacapp ();}
-  {extern void proto_reg_handoff_bacnet (void); proto_reg_handoff_bacnet ();}
-  {extern void proto_reg_handoff_bacp (void); proto_reg_handoff_bacp ();}
-  {extern void proto_reg_handoff_bap (void); proto_reg_handoff_bap ();}
-  {extern void proto_reg_handoff_beep (void); proto_reg_handoff_beep ();}
-  {extern void proto_reg_handoff_bgp (void); proto_reg_handoff_bgp ();}
-  {extern void proto_reg_handoff_bicc (void); proto_reg_handoff_bicc ();}
-  {extern void proto_reg_handoff_bofl (void); proto_reg_handoff_bofl ();}
-  {extern void proto_reg_handoff_bootp (void); proto_reg_handoff_bootp ();}
-  {extern void proto_reg_handoff_bootparams (void); proto_reg_handoff_bootparams ();}
-  {extern void proto_reg_handoff_bossvr (void); proto_reg_handoff_bossvr ();}
-  {extern void proto_reg_handoff_bpdu (void); proto_reg_handoff_bpdu ();}
-  {extern void proto_reg_handoff_brdwlk (void); proto_reg_handoff_brdwlk ();}
-  {extern void proto_reg_handoff_bssap (void); proto_reg_handoff_bssap ();}
-  {extern void proto_reg_handoff_bssgp (void); proto_reg_handoff_bssgp ();}
-  {extern void proto_reg_handoff_butc (void); proto_reg_handoff_butc ();}
-  {extern void proto_reg_handoff_bvlc (void); proto_reg_handoff_bvlc ();}
-  {extern void proto_reg_handoff_cbcp (void); proto_reg_handoff_cbcp ();}
-  {extern void proto_reg_handoff_ccp (void); proto_reg_handoff_ccp ();}
-  {extern void proto_reg_handoff_cdp (void); proto_reg_handoff_cdp ();}
-  {extern void proto_reg_handoff_cdpcp (void); proto_reg_handoff_cdpcp ();}
-  {extern void proto_reg_handoff_cds_clerkserver (void); proto_reg_handoff_cds_clerkserver ();}
-  {extern void proto_reg_handoff_cds_solicit (void); proto_reg_handoff_cds_solicit ();}
-  {extern void proto_reg_handoff_cgmp (void); proto_reg_handoff_cgmp ();}
-  {extern void proto_reg_handoff_chap (void); proto_reg_handoff_chap ();}
-  {extern void proto_reg_handoff_chdlc (void); proto_reg_handoff_chdlc ();}
-  {extern void proto_reg_handoff_cipencap (void); proto_reg_handoff_cipencap ();}
-  {extern void proto_reg_handoff_clearcase (void); proto_reg_handoff_clearcase ();}
-  {extern void proto_reg_handoff_clip (void); proto_reg_handoff_clip ();}
-  {extern void proto_reg_handoff_clnp (void); proto_reg_handoff_clnp ();}
-  {extern void proto_reg_handoff_comp_data (void); proto_reg_handoff_comp_data ();}
-  {extern void proto_reg_handoff_conv (void); proto_reg_handoff_conv ();}
-  {extern void proto_reg_handoff_cops (void); proto_reg_handoff_cops ();}
-  {extern void proto_reg_handoff_cosine (void); proto_reg_handoff_cosine ();}
-  {extern void proto_reg_handoff_cpha (void); proto_reg_handoff_cpha ();}
-  {extern void proto_reg_handoff_cprpc_server (void); proto_reg_handoff_cprpc_server ();}
-  {extern void proto_reg_handoff_cups (void); proto_reg_handoff_cups ();}
-  {extern void proto_reg_handoff_dccp (void); proto_reg_handoff_dccp ();}
-  {extern void proto_reg_handoff_dce_update (void); proto_reg_handoff_dce_update ();}
-  {extern void proto_reg_handoff_dcerpc (void); proto_reg_handoff_dcerpc ();}
-  {extern void proto_reg_handoff_dcerpc_atsvc (void); proto_reg_handoff_dcerpc_atsvc ();}
-  {extern void proto_reg_handoff_dcerpc_browser (void); proto_reg_handoff_dcerpc_browser ();}
-  {extern void proto_reg_handoff_dcerpc_dfs (void); proto_reg_handoff_dcerpc_dfs ();}
-  {extern void proto_reg_handoff_dcerpc_dnsserver (void); proto_reg_handoff_dcerpc_dnsserver ();}
-  {extern void proto_reg_handoff_dcerpc_drsuapi (void); proto_reg_handoff_dcerpc_drsuapi ();}
-  {extern void proto_reg_handoff_dcerpc_initshutdown (void); proto_reg_handoff_dcerpc_initshutdown ();}
-  {extern void proto_reg_handoff_dcerpc_lsa (void); proto_reg_handoff_dcerpc_lsa ();}
-  {extern void proto_reg_handoff_dcerpc_lsa_ds (void); proto_reg_handoff_dcerpc_lsa_ds ();}
-  {extern void proto_reg_handoff_dcerpc_mapi (void); proto_reg_handoff_dcerpc_mapi ();}
-  {extern void proto_reg_handoff_dcerpc_messenger (void); proto_reg_handoff_dcerpc_messenger ();}
-  {extern void proto_reg_handoff_dcerpc_netlogon (void); proto_reg_handoff_dcerpc_netlogon ();}
-  {extern void proto_reg_handoff_dcerpc_reg (void); proto_reg_handoff_dcerpc_reg ();}
-  {extern void proto_reg_handoff_dcerpc_samr (void); proto_reg_handoff_dcerpc_samr ();}
-  {extern void proto_reg_handoff_dcerpc_spoolss (void); proto_reg_handoff_dcerpc_spoolss ();}
-  {extern void proto_reg_handoff_dcerpc_srvsvc (void); proto_reg_handoff_dcerpc_srvsvc ();}
-  {extern void proto_reg_handoff_dcerpc_svcctl (void); proto_reg_handoff_dcerpc_svcctl ();}
-  {extern void proto_reg_handoff_dcerpc_tapi (void); proto_reg_handoff_dcerpc_tapi ();}
-  {extern void proto_reg_handoff_dcerpc_wkssvc (void); proto_reg_handoff_dcerpc_wkssvc ();}
-  {extern void proto_reg_handoff_ddtp (void); proto_reg_handoff_ddtp ();}
-  {extern void proto_reg_handoff_dec_bpdu (void); proto_reg_handoff_dec_bpdu ();}
-  {extern void proto_reg_handoff_dhcpv6 (void); proto_reg_handoff_dhcpv6 ();}
-  {extern void proto_reg_handoff_diameter (void); proto_reg_handoff_diameter ();}
-  {extern void proto_reg_handoff_distcc (void); proto_reg_handoff_distcc ();}
-  {extern void proto_reg_handoff_dlsw (void); proto_reg_handoff_dlsw ();}
   {extern void proto_reg_handoff_dns (void); proto_reg_handoff_dns ();}
-  {extern void proto_reg_handoff_dsi (void); proto_reg_handoff_dsi ();}
-  {extern void proto_reg_handoff_dtsprovider (void); proto_reg_handoff_dtsprovider ();}
-  {extern void proto_reg_handoff_dtsstime_req (void); proto_reg_handoff_dtsstime_req ();}
-  {extern void proto_reg_handoff_eap (void); proto_reg_handoff_eap ();}
-  {extern void proto_reg_handoff_eapol (void); proto_reg_handoff_eapol ();}
-  {extern void proto_reg_handoff_echo (void); proto_reg_handoff_echo ();}
-  {extern void proto_reg_handoff_edonkey (void); proto_reg_handoff_edonkey ();}
-  {extern void proto_reg_handoff_eigrp (void); proto_reg_handoff_eigrp ();}
-  {extern void proto_reg_handoff_enc (void); proto_reg_handoff_enc ();}
-  {extern void proto_reg_handoff_epm (void); proto_reg_handoff_epm ();}
-  {extern void proto_reg_handoff_esis (void); proto_reg_handoff_esis ();}
   {extern void proto_reg_handoff_eth (void); proto_reg_handoff_eth ();}
-  {extern void proto_reg_handoff_etherip (void); proto_reg_handoff_etherip ();}
   {extern void proto_reg_handoff_ethertype (void); proto_reg_handoff_ethertype ();}
-  {extern void proto_reg_handoff_fc (void); proto_reg_handoff_fc ();}
-  {extern void proto_reg_handoff_fcct (void); proto_reg_handoff_fcct ();}
-  {extern void proto_reg_handoff_fcdns (void); proto_reg_handoff_fcdns ();}
-  {extern void proto_reg_handoff_fcels (void); proto_reg_handoff_fcels ();}
-  {extern void proto_reg_handoff_fcfcs (void); proto_reg_handoff_fcfcs ();}
-  {extern void proto_reg_handoff_fcfzs (void); proto_reg_handoff_fcfzs ();}
-  {extern void proto_reg_handoff_fcip (void); proto_reg_handoff_fcip ();}
-  {extern void proto_reg_handoff_fcp (void); proto_reg_handoff_fcp ();}
-  {extern void proto_reg_handoff_fcsbccs (void); proto_reg_handoff_fcsbccs ();}
-  {extern void proto_reg_handoff_fcsp (void); proto_reg_handoff_fcsp ();}
-  {extern void proto_reg_handoff_fcswils (void); proto_reg_handoff_fcswils ();}
-  {extern void proto_reg_handoff_fddi (void); proto_reg_handoff_fddi ();}
-  {extern void proto_reg_handoff_fix (void); proto_reg_handoff_fix ();}
-  {extern void proto_reg_handoff_fldb (void); proto_reg_handoff_fldb ();}
-  {extern void proto_reg_handoff_fr (void); proto_reg_handoff_fr ();}
   {extern void proto_reg_handoff_frame (void); proto_reg_handoff_frame ();}
-  {extern void proto_reg_handoff_ftp (void); proto_reg_handoff_ftp ();}
-  {extern void proto_reg_handoff_ftserver (void); proto_reg_handoff_ftserver ();}
-  {extern void proto_reg_handoff_fw1 (void); proto_reg_handoff_fw1 ();}
-  {extern void proto_reg_handoff_giop (void); proto_reg_handoff_giop ();}
-  {extern void proto_reg_handoff_gmrp (void); proto_reg_handoff_gmrp ();}
-  {extern void proto_reg_handoff_gnutella (void); proto_reg_handoff_gnutella ();}
-  {extern void proto_reg_handoff_gprs_ns (void); proto_reg_handoff_gprs_ns ();}
-  {extern void proto_reg_handoff_gre (void); proto_reg_handoff_gre ();}
-  {extern void proto_reg_handoff_gsm_a (void); proto_reg_handoff_gsm_a ();}
-  {extern void proto_reg_handoff_gsm_sms (void); proto_reg_handoff_gsm_sms ();}
-  {extern void proto_reg_handoff_gssapi (void); proto_reg_handoff_gssapi ();}
-  {extern void proto_reg_handoff_gtp (void); proto_reg_handoff_gtp ();}
-  {extern void proto_reg_handoff_gvrp (void); proto_reg_handoff_gvrp ();}
-  {extern void proto_reg_handoff_h1 (void); proto_reg_handoff_h1 ();}
-  {extern void proto_reg_handoff_h225 (void); proto_reg_handoff_h225 ();}
-  {extern void proto_reg_handoff_h245 (void); proto_reg_handoff_h245 ();}
-  {extern void proto_reg_handoff_h261 (void); proto_reg_handoff_h261 ();}
-  {extern void proto_reg_handoff_h263 (void); proto_reg_handoff_h263 ();}
-  {extern void proto_reg_handoff_h4501 (void); proto_reg_handoff_h4501 ();}
-  {extern void proto_reg_handoff_hclnfsd (void); proto_reg_handoff_hclnfsd ();}
-  {extern void proto_reg_handoff_hpext (void); proto_reg_handoff_hpext ();}
-  {extern void proto_reg_handoff_hsrp (void); proto_reg_handoff_hsrp ();}
   {extern void proto_reg_handoff_http (void); proto_reg_handoff_http ();}
-  {extern void proto_reg_handoff_hyperscsi (void); proto_reg_handoff_hyperscsi ();}
-  {extern void proto_reg_handoff_iapp (void); proto_reg_handoff_iapp ();}
-  {extern void proto_reg_handoff_ib (void); proto_reg_handoff_ib ();}
-  {extern void proto_reg_handoff_icap (void); proto_reg_handoff_icap ();}
   {extern void proto_reg_handoff_icmp (void); proto_reg_handoff_icmp ();}
-  {extern void proto_reg_handoff_icmpv6 (void); proto_reg_handoff_icmpv6 ();}
-  {extern void proto_reg_handoff_icp (void); proto_reg_handoff_icp ();}
-  {extern void proto_reg_handoff_icq (void); proto_reg_handoff_icq ();}
-  {extern void proto_reg_handoff_ieee80211 (void); proto_reg_handoff_ieee80211 ();}
-  {extern void proto_reg_handoff_ieee802_3 (void); proto_reg_handoff_ieee802_3 ();}
-  {extern void proto_reg_handoff_igmp (void); proto_reg_handoff_igmp ();}
-  {extern void proto_reg_handoff_igrp (void); proto_reg_handoff_igrp ();}
-  {extern void proto_reg_handoff_imap (void); proto_reg_handoff_imap ();}
   {extern void proto_reg_handoff_ip (void); proto_reg_handoff_ip ();}
-  {extern void proto_reg_handoff_ipcp (void); proto_reg_handoff_ipcp ();}
-  {extern void proto_reg_handoff_ipfc (void); proto_reg_handoff_ipfc ();}
-  {extern void proto_reg_handoff_ipmi (void); proto_reg_handoff_ipmi ();}
-  {extern void proto_reg_handoff_ipp (void); proto_reg_handoff_ipp ();}
-  {extern void proto_reg_handoff_ipsec (void); proto_reg_handoff_ipsec ();}
-  {extern void proto_reg_handoff_ipv6 (void); proto_reg_handoff_ipv6 ();}
-  {extern void proto_reg_handoff_ipv6cp (void); proto_reg_handoff_ipv6cp ();}
-  {extern void proto_reg_handoff_ipx (void); proto_reg_handoff_ipx ();}
-  {extern void proto_reg_handoff_ipxwan (void); proto_reg_handoff_ipxwan ();}
-  {extern void proto_reg_handoff_irc (void); proto_reg_handoff_irc ();}
-  {extern void proto_reg_handoff_isakmp (void); proto_reg_handoff_isakmp ();}
-  {extern void proto_reg_handoff_iscsi (void); proto_reg_handoff_iscsi ();}
-  {extern void proto_reg_handoff_isdn (void); proto_reg_handoff_isdn ();}
-  {extern void proto_reg_handoff_isis (void); proto_reg_handoff_isis ();}
-  {extern void proto_reg_handoff_isl (void); proto_reg_handoff_isl ();}
-  {extern void proto_reg_handoff_isns (void); proto_reg_handoff_isns ();}
-  {extern void proto_reg_handoff_isup (void); proto_reg_handoff_isup ();}
-  {extern void proto_reg_handoff_iua (void); proto_reg_handoff_iua ();}
-  {extern void proto_reg_handoff_jabber (void); proto_reg_handoff_jabber ();}
-  {extern void proto_reg_handoff_kadm5 (void); proto_reg_handoff_kadm5 ();}
-  {extern void proto_reg_handoff_kerberos (void); proto_reg_handoff_kerberos ();}
-  {extern void proto_reg_handoff_klm (void); proto_reg_handoff_klm ();}
-  {extern void proto_reg_handoff_krb5rpc (void); proto_reg_handoff_krb5rpc ();}
-  {extern void proto_reg_handoff_l2tp (void); proto_reg_handoff_l2tp ();}
-  {extern void proto_reg_handoff_lacpdu (void); proto_reg_handoff_lacpdu ();}
-  {extern void proto_reg_handoff_lapb (void); proto_reg_handoff_lapb ();}
-  {extern void proto_reg_handoff_lapbether (void); proto_reg_handoff_lapbether ();}
-  {extern void proto_reg_handoff_lapd (void); proto_reg_handoff_lapd ();}
-  {extern void proto_reg_handoff_laplink (void); proto_reg_handoff_laplink ();}
-  {extern void proto_reg_handoff_lcp (void); proto_reg_handoff_lcp ();}
-  {extern void proto_reg_handoff_ldap (void); proto_reg_handoff_ldap ();}
-  {extern void proto_reg_handoff_ldp (void); proto_reg_handoff_ldp ();}
-  {extern void proto_reg_handoff_llc (void); proto_reg_handoff_llc ();}
-  {extern void proto_reg_handoff_lmi (void); proto_reg_handoff_lmi ();}
-  {extern void proto_reg_handoff_lmp (void); proto_reg_handoff_lmp ();}
-  {extern void proto_reg_handoff_lpd (void); proto_reg_handoff_lpd ();}
-  {extern void proto_reg_handoff_lwapp (void); proto_reg_handoff_lwapp ();}
-  {extern void proto_reg_handoff_m2pa (void); proto_reg_handoff_m2pa ();}
-  {extern void proto_reg_handoff_m2tp (void); proto_reg_handoff_m2tp ();}
-  {extern void proto_reg_handoff_m2ua (void); proto_reg_handoff_m2ua ();}
-  {extern void proto_reg_handoff_m3ua (void); proto_reg_handoff_m3ua ();}
-  {extern void proto_reg_handoff_mbtcp (void); proto_reg_handoff_mbtcp ();}
-  {extern void proto_reg_handoff_mdshdr (void); proto_reg_handoff_mdshdr ();}
-  {extern void proto_reg_handoff_mgmt (void); proto_reg_handoff_mgmt ();}
-  {extern void proto_reg_handoff_mip (void); proto_reg_handoff_mip ();}
-  {extern void proto_reg_handoff_mip6 (void); proto_reg_handoff_mip6 ();}
-  {extern void proto_reg_handoff_mmse (void); proto_reg_handoff_mmse ();}
-  {extern void proto_reg_handoff_mount (void); proto_reg_handoff_mount ();}
-  {extern void proto_reg_handoff_mp (void); proto_reg_handoff_mp ();}
-  {extern void proto_reg_handoff_mpeg1 (void); proto_reg_handoff_mpeg1 ();}
-  {extern void proto_reg_handoff_mpls (void); proto_reg_handoff_mpls ();}
-  {extern void proto_reg_handoff_mplscp (void); proto_reg_handoff_mplscp ();}
-  {extern void proto_reg_handoff_msdp (void); proto_reg_handoff_msdp ();}
-  {extern void proto_reg_handoff_msnms (void); proto_reg_handoff_msnms ();}
-  {extern void proto_reg_handoff_msproxy (void); proto_reg_handoff_msproxy ();}
-  {extern void proto_reg_handoff_mtp2 (void); proto_reg_handoff_mtp2 ();}
-  {extern void proto_reg_handoff_mtp3 (void); proto_reg_handoff_mtp3 ();}
-  {extern void proto_reg_handoff_mtp3mg (void); proto_reg_handoff_mtp3mg ();}
-  {extern void proto_reg_handoff_mysql (void); proto_reg_handoff_mysql ();}
-  {extern void proto_reg_handoff_nbipx (void); proto_reg_handoff_nbipx ();}
-  {extern void proto_reg_handoff_nbt (void); proto_reg_handoff_nbt ();}
-  {extern void proto_reg_handoff_ncp (void); proto_reg_handoff_ncp ();}
-  {extern void proto_reg_handoff_ndmp (void); proto_reg_handoff_ndmp ();}
-  {extern void proto_reg_handoff_ndps (void); proto_reg_handoff_ndps ();}
-  {extern void proto_reg_handoff_netbios (void); proto_reg_handoff_netbios ();}
-  {extern void proto_reg_handoff_netflow (void); proto_reg_handoff_netflow ();}
-  {extern void proto_reg_handoff_nfs (void); proto_reg_handoff_nfs ();}
-  {extern void proto_reg_handoff_nfsacl (void); proto_reg_handoff_nfsacl ();}
-  {extern void proto_reg_handoff_nfsauth (void); proto_reg_handoff_nfsauth ();}
-  {extern void proto_reg_handoff_nis (void); proto_reg_handoff_nis ();}
-  {extern void proto_reg_handoff_niscb (void); proto_reg_handoff_niscb ();}
-  {extern void proto_reg_handoff_nlm (void); proto_reg_handoff_nlm ();}
-  {extern void proto_reg_handoff_nlsp (void); proto_reg_handoff_nlsp ();}
-  {extern void proto_reg_handoff_nmpi (void); proto_reg_handoff_nmpi ();}
-  {extern void proto_reg_handoff_nntp (void); proto_reg_handoff_nntp ();}
-  {extern void proto_reg_handoff_nspi (void); proto_reg_handoff_nspi ();}
-  {extern void proto_reg_handoff_ntlmssp (void); proto_reg_handoff_ntlmssp ();}
-  {extern void proto_reg_handoff_ntp (void); proto_reg_handoff_ntp ();}
-  {extern void proto_reg_handoff_null (void); proto_reg_handoff_null ();}
-  {extern void proto_reg_handoff_old_pflog (void); proto_reg_handoff_old_pflog ();}
-  {extern void proto_reg_handoff_osi (void); proto_reg_handoff_osi ();}
-  {extern void proto_reg_handoff_ospf (void); proto_reg_handoff_ospf ();}
-  {extern void proto_reg_handoff_oxid (void); proto_reg_handoff_oxid ();}
-  {extern void proto_reg_handoff_pap (void); proto_reg_handoff_pap ();}
-  {extern void proto_reg_handoff_pcnfsd (void); proto_reg_handoff_pcnfsd ();}
-  {extern void proto_reg_handoff_per (void); proto_reg_handoff_per ();}
-  {extern void proto_reg_handoff_pflog (void); proto_reg_handoff_pflog ();}
-  {extern void proto_reg_handoff_pgm (void); proto_reg_handoff_pgm ();}
-  {extern void proto_reg_handoff_pim (void); proto_reg_handoff_pim ();}
   {extern void proto_reg_handoff_pop (void); proto_reg_handoff_pop ();}
-  {extern void proto_reg_handoff_portmap (void); proto_reg_handoff_portmap ();}
-  {extern void proto_reg_handoff_ppp (void); proto_reg_handoff_ppp ();}
-  {extern void proto_reg_handoff_pppmux (void); proto_reg_handoff_pppmux ();}
-  {extern void proto_reg_handoff_pppmuxcp (void); proto_reg_handoff_pppmuxcp ();}
-  {extern void proto_reg_handoff_pppoed (void); proto_reg_handoff_pppoed ();}
-  {extern void proto_reg_handoff_pppoes (void); proto_reg_handoff_pppoes ();}
-  {extern void proto_reg_handoff_pptp (void); proto_reg_handoff_pptp ();}
-  {extern void proto_reg_handoff_prism (void); proto_reg_handoff_prism ();}
-  {extern void proto_reg_handoff_q931 (void); proto_reg_handoff_q931 ();}
-  {extern void proto_reg_handoff_q933 (void); proto_reg_handoff_q933 ();}
-  {extern void proto_reg_handoff_qllc (void); proto_reg_handoff_qllc ();}
-  {extern void proto_reg_handoff_quake (void); proto_reg_handoff_quake ();}
-  {extern void proto_reg_handoff_quake2 (void); proto_reg_handoff_quake2 ();}
-  {extern void proto_reg_handoff_quake3 (void); proto_reg_handoff_quake3 ();}
-  {extern void proto_reg_handoff_quakeworld (void); proto_reg_handoff_quakeworld ();}
-  {extern void proto_reg_handoff_radius (void); proto_reg_handoff_radius ();}
-  {extern void proto_reg_handoff_ranap (void); proto_reg_handoff_ranap ();}
-  {extern void proto_reg_handoff_raw (void); proto_reg_handoff_raw ();}
-  {extern void proto_reg_handoff_remact (void); proto_reg_handoff_remact ();}
-  {extern void proto_reg_handoff_rep_proc (void); proto_reg_handoff_rep_proc ();}
-  {extern void proto_reg_handoff_rip (void); proto_reg_handoff_rip ();}
-  {extern void proto_reg_handoff_ripng (void); proto_reg_handoff_ripng ();}
-  {extern void proto_reg_handoff_rlogin (void); proto_reg_handoff_rlogin ();}
-  {extern void proto_reg_handoff_rmcp (void); proto_reg_handoff_rmcp ();}
-  {extern void proto_reg_handoff_rmi (void); proto_reg_handoff_rmi ();}
-  {extern void proto_reg_handoff_rmp (void); proto_reg_handoff_rmp ();}
-  {extern void proto_reg_handoff_roverride (void); proto_reg_handoff_roverride ();}
-  {extern void proto_reg_handoff_rpc (void); proto_reg_handoff_rpc ();}
-  {extern void proto_reg_handoff_rpl (void); proto_reg_handoff_rpl ();}
-  {extern void proto_reg_handoff_rpriv (void); proto_reg_handoff_rpriv ();}
-  {extern void proto_reg_handoff_rquota (void); proto_reg_handoff_rquota ();}
-  {extern void proto_reg_handoff_rs_acct (void); proto_reg_handoff_rs_acct ();}
-  {extern void proto_reg_handoff_rs_attr (void); proto_reg_handoff_rs_attr ();}
-  {extern void proto_reg_handoff_rs_bind (void); proto_reg_handoff_rs_bind ();}
-  {extern void proto_reg_handoff_rs_misc (void); proto_reg_handoff_rs_misc ();}
-  {extern void proto_reg_handoff_rs_pgo (void); proto_reg_handoff_rs_pgo ();}
-  {extern void proto_reg_handoff_rs_repadm (void); proto_reg_handoff_rs_repadm ();}
-  {extern void proto_reg_handoff_rs_replist (void); proto_reg_handoff_rs_replist ();}
-  {extern void proto_reg_handoff_rs_unix (void); proto_reg_handoff_rs_unix ();}
-  {extern void proto_reg_handoff_rsec_login (void); proto_reg_handoff_rsec_login ();}
-  {extern void proto_reg_handoff_rsh (void); proto_reg_handoff_rsh ();}
-  {extern void proto_reg_handoff_rstat (void); proto_reg_handoff_rstat ();}
-  {extern void proto_reg_handoff_rsvp (void); proto_reg_handoff_rsvp ();}
-  {extern void proto_reg_handoff_rsync (void); proto_reg_handoff_rsync ();}
-  {extern void proto_reg_handoff_rtcp (void); proto_reg_handoff_rtcp ();}
-  {extern void proto_reg_handoff_rtp (void); proto_reg_handoff_rtp ();}
-  {extern void proto_reg_handoff_rtp_events (void); proto_reg_handoff_rtp_events ();}
-  {extern void proto_reg_handoff_rtsp (void); proto_reg_handoff_rtsp ();}
-  {extern void proto_reg_handoff_rwall (void); proto_reg_handoff_rwall ();}
-  {extern void proto_reg_handoff_rx (void); proto_reg_handoff_rx ();}
-  {extern void proto_reg_handoff_sadmind (void); proto_reg_handoff_sadmind ();}
-  {extern void proto_reg_handoff_sap (void); proto_reg_handoff_sap ();}
-  {extern void proto_reg_handoff_sccp (void); proto_reg_handoff_sccp ();}
-  {extern void proto_reg_handoff_sccpmg (void); proto_reg_handoff_sccpmg ();}
-  {extern void proto_reg_handoff_sctp (void); proto_reg_handoff_sctp ();}
-  {extern void proto_reg_handoff_sdlc (void); proto_reg_handoff_sdlc ();}
-  {extern void proto_reg_handoff_secidmap (void); proto_reg_handoff_secidmap ();}
-  {extern void proto_reg_handoff_sflow (void); proto_reg_handoff_sflow ();}
-  {extern void proto_reg_handoff_sip (void); proto_reg_handoff_sip ();}
-  {extern void proto_reg_handoff_skinny (void); proto_reg_handoff_skinny ();}
-  {extern void proto_reg_handoff_slarp (void); proto_reg_handoff_slarp ();}
-  {extern void proto_reg_handoff_slimp3 (void); proto_reg_handoff_slimp3 ();}
-  {extern void proto_reg_handoff_sll (void); proto_reg_handoff_sll ();}
-  {extern void proto_reg_handoff_smb (void); proto_reg_handoff_smb ();}
-  {extern void proto_reg_handoff_smb_mailslot (void); proto_reg_handoff_smb_mailslot ();}
-  {extern void proto_reg_handoff_smb_pipe (void); proto_reg_handoff_smb_pipe ();}
-  {extern void proto_reg_handoff_smb_sidsnooping (void); proto_reg_handoff_smb_sidsnooping ();}
-  {extern void proto_reg_handoff_smpp (void); proto_reg_handoff_smpp ();}
   {extern void proto_reg_handoff_smtp (void); proto_reg_handoff_smtp ();}
-  {extern void proto_reg_handoff_smux (void); proto_reg_handoff_smux ();}
-  {extern void proto_reg_handoff_sna (void); proto_reg_handoff_sna ();}
-  {extern void proto_reg_handoff_snaeth (void); proto_reg_handoff_snaeth ();}
-  {extern void proto_reg_handoff_snmp (void); proto_reg_handoff_snmp ();}
-  {extern void proto_reg_handoff_socks (void); proto_reg_handoff_socks ();}
-  {extern void proto_reg_handoff_sonmp (void); proto_reg_handoff_sonmp ();}
-  {extern void proto_reg_handoff_spnego (void); proto_reg_handoff_spnego ();}
-  {extern void proto_reg_handoff_spray (void); proto_reg_handoff_spray ();}
-  {extern void proto_reg_handoff_srvloc (void); proto_reg_handoff_srvloc ();}
-  {extern void proto_reg_handoff_sscop (void); proto_reg_handoff_sscop ();}
-  {extern void proto_reg_handoff_ssh (void); proto_reg_handoff_ssh ();}
-  {extern void proto_reg_handoff_ssl (void); proto_reg_handoff_ssl ();}
-  {extern void proto_reg_handoff_stat (void); proto_reg_handoff_stat ();}
-  {extern void proto_reg_handoff_statnotify (void); proto_reg_handoff_statnotify ();}
-  {extern void proto_reg_handoff_stun (void); proto_reg_handoff_stun ();}
-  {extern void proto_reg_handoff_sua (void); proto_reg_handoff_sua ();}
-  {extern void proto_reg_handoff_syslog (void); proto_reg_handoff_syslog ();}
-  {extern void proto_reg_handoff_t38 (void); proto_reg_handoff_t38 ();}
-  {extern void proto_reg_handoff_tacacs (void); proto_reg_handoff_tacacs ();}
-  {extern void proto_reg_handoff_tacplus (void); proto_reg_handoff_tacplus ();}
-  {extern void proto_reg_handoff_tcap (void); proto_reg_handoff_tcap ();}
   {extern void proto_reg_handoff_tcp (void); proto_reg_handoff_tcp ();}
-  {extern void proto_reg_handoff_tds (void); proto_reg_handoff_tds ();}
-  {extern void proto_reg_handoff_telnet (void); proto_reg_handoff_telnet ();}
-  {extern void proto_reg_handoff_teredo (void); proto_reg_handoff_teredo ();}
-  {extern void proto_reg_handoff_tftp (void); proto_reg_handoff_tftp ();}
-  {extern void proto_reg_handoff_time (void); proto_reg_handoff_time ();}
-  {extern void proto_reg_handoff_tkn4int (void); proto_reg_handoff_tkn4int ();}
-  {extern void proto_reg_handoff_tns (void); proto_reg_handoff_tns ();}
-  {extern void proto_reg_handoff_tpcp (void); proto_reg_handoff_tpcp ();}
-  {extern void proto_reg_handoff_tpkt (void); proto_reg_handoff_tpkt ();}
-  {extern void proto_reg_handoff_tr (void); proto_reg_handoff_tr ();}
-  {extern void proto_reg_handoff_tsp (void); proto_reg_handoff_tsp ();}
-  {extern void proto_reg_handoff_tzsp (void); proto_reg_handoff_tzsp ();}
-  {extern void proto_reg_handoff_ubikdisk (void); proto_reg_handoff_ubikdisk ();}
-  {extern void proto_reg_handoff_ubikvote (void); proto_reg_handoff_ubikvote ();}
-  {extern void proto_reg_handoff_ucp (void); proto_reg_handoff_ucp ();}
   {extern void proto_reg_handoff_udp (void); proto_reg_handoff_udp ();}
-  {extern void proto_reg_handoff_udpencap (void); proto_reg_handoff_udpencap ();}
-  {extern void proto_reg_handoff_v120 (void); proto_reg_handoff_v120 ();}
-  {extern void proto_reg_handoff_vines_arp (void); proto_reg_handoff_vines_arp ();}
-  {extern void proto_reg_handoff_vines_echo (void); proto_reg_handoff_vines_echo ();}
-  {extern void proto_reg_handoff_vines_frp (void); proto_reg_handoff_vines_frp ();}
-  {extern void proto_reg_handoff_vines_icp (void); proto_reg_handoff_vines_icp ();}
-  {extern void proto_reg_handoff_vines_ip (void); proto_reg_handoff_vines_ip ();}
-  {extern void proto_reg_handoff_vines_ipc (void); proto_reg_handoff_vines_ipc ();}
-  {extern void proto_reg_handoff_vines_llc (void); proto_reg_handoff_vines_llc ();}
-  {extern void proto_reg_handoff_vines_rtp (void); proto_reg_handoff_vines_rtp ();}
-  {extern void proto_reg_handoff_vines_spp (void); proto_reg_handoff_vines_spp ();}
-  {extern void proto_reg_handoff_vj (void); proto_reg_handoff_vj ();}
-  {extern void proto_reg_handoff_vlan (void); proto_reg_handoff_vlan ();}
-  {extern void proto_reg_handoff_vrrp (void); proto_reg_handoff_vrrp ();}
-  {extern void proto_reg_handoff_vtp (void); proto_reg_handoff_vtp ();}
-  {extern void proto_reg_handoff_wbxml (void); proto_reg_handoff_wbxml ();}
-  {extern void proto_reg_handoff_wccp (void); proto_reg_handoff_wccp ();}
-  {extern void proto_reg_handoff_wcp (void); proto_reg_handoff_wcp ();}
-  {extern void proto_reg_handoff_wfleet_hdlc (void); proto_reg_handoff_wfleet_hdlc ();}
-  {extern void proto_reg_handoff_who (void); proto_reg_handoff_who ();}
-  {extern void proto_reg_handoff_wlancap (void); proto_reg_handoff_wlancap ();}
-  {extern void proto_reg_handoff_wsp (void); proto_reg_handoff_wsp ();}
-  {extern void proto_reg_handoff_wtls (void); proto_reg_handoff_wtls ();}
-  {extern void proto_reg_handoff_wtp (void); proto_reg_handoff_wtp ();}
-  {extern void proto_reg_handoff_x11 (void); proto_reg_handoff_x11 ();}
-  {extern void proto_reg_handoff_x25 (void); proto_reg_handoff_x25 ();}
-  {extern void proto_reg_handoff_x29 (void); proto_reg_handoff_x29 ();}
-  {extern void proto_reg_handoff_xdmcp (void); proto_reg_handoff_xdmcp ();}
-  {extern void proto_reg_handoff_xot (void); proto_reg_handoff_xot ();}
-  {extern void proto_reg_handoff_xyplex (void); proto_reg_handoff_xyplex ();}
-  {extern void proto_reg_handoff_yhoo (void); proto_reg_handoff_yhoo ();}
-  {extern void proto_reg_handoff_ymsg (void); proto_reg_handoff_ymsg ();}
-  {extern void proto_reg_handoff_ypbind (void); proto_reg_handoff_ypbind ();}
-  {extern void proto_reg_handoff_yppasswd (void); proto_reg_handoff_yppasswd ();}
-  {extern void proto_reg_handoff_ypserv (void); proto_reg_handoff_ypserv ();}
-  {extern void proto_reg_handoff_ypxfr (void); proto_reg_handoff_ypxfr ();}
-  {extern void proto_reg_handoff_zebra (void); proto_reg_handoff_zebra ();}
 }
diff -Naur ethereal-0.9.16/sql.c ethereal-0.9.16_new/sql.c
--- ethereal-0.9.16/sql.c	1970-01-01 10:00:00.000000000 +1000
+++ ethereal-0.9.16_new/sql.c	2003-11-26 19:29:40.000000000 +1100
@@ -0,0 +1,623 @@
+/* sql.c
+ * This file is part of a patch to generate SQL automatically from TCPDUMP
+ *
+ * Michael Cohen michael.cohen@netspeed.com.au
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#define HAVE_STDARG_H
+
+#include <epan/epan.h>
+#include <epan/epan_dissect.h>
+#include <epan/tvbuff.h>
+#include <epan/packet.h>
+#include <epan/proto.h>
+#include "print.h"
+#include "ps.h"
+#include "util.h"
+#include "packet-data.h"
+#include "sql.h"
+
+gchar        post[ITEM_LABEL_LENGTH]="";
+int             frame_no=0;
+// This string is used to append additional SQL statements to each insert. This is used for inserting special tables which do not follow the mold well. Note that the schema for these tables must also be placed in epan/proto.c
+GString *additional_sql = NULL;
+static struct edge_entry *edge_table=NULL;
+static struct edge_entry *edge_table_end=NULL;
+
+static struct node_entry *node_table=NULL;
+static struct node_entry *node_table_end = NULL;
+
+//These are hash tables used to index the node and edge tables.
+static struct hash_link *node_hashes[SIZE_OF_HASHTABLE];
+static struct hash_link *edge_hashes[SIZE_OF_HASHTABLE];
+
+
+char *kb_ptr[MAX_KB_PTR];
+
+static struct edge_entry *test_edge=NULL;
+
+void init_kb_ptr() {
+
+  bzero(kb_ptr,sizeof(kb_ptr));
+
+  kb_ptr[ETH_SRC]="eth.src";
+  kb_ptr[IP_SRC]="ip.src";
+  kb_ptr[IP_DST]="ip.dst";
+  kb_ptr[ETH]="eth";
+  kb_ptr[IP]="ip";
+  kb_ptr[ICMP] = "icmp";
+  kb_ptr[ICMP_TYPE] = "icmp.type";
+  kb_ptr[TCP] = "tcp";
+  kb_ptr[TCP_SRCPORT] = "tcp.srcport";
+  kb_ptr[TCP_FLAGS] = "tcp.flags";
+  kb_ptr[DNS_DATA] = "dns_data";
+  kb_ptr[DNS_DATA_DATA] = "dns_data.data";
+  kb_ptr[DNS] = "dns";
+  kb_ptr[DNS_NAME]= "dns_data.name";
+  kb_ptr[DNS_TYPE]= "dns_data.type";
+  kb_ptr[POP]= "pop";
+  kb_ptr[POP_REQ_COMMAND]= "pop.req.command";
+  kb_ptr[POP_REQ_PARAMETER]= "pop.req.parameter";
+
+  //Init the hash tables:
+  bzero(node_hashes,SIZE_OF_HASHTABLE);
+  bzero(edge_hashes,SIZE_OF_HASHTABLE);
+
+  //Initialise the test edge
+  if(!test_edge) {
+    test_edge = (struct edge_entry *)new_object(sizeof(struct edge_entry));
+  };
+};
+
+//Function prints the string given in ptr as an SQL escaped string sequence. 
+void print_sql_string(FILE *fh, const unsigned char *ptr, int length) {
+  int i;
+  for(i=0;i<length;i++) {
+    switch(*(ptr+i)) {
+    case 0:
+      fprintf(fh,"\\0");
+      break;
+    case '\'':
+      fprintf(fh,"\\'");
+      break;
+    case '\"':
+      fprintf(fh,"\\\"");
+      break;
+    case '\n':
+      fprintf(fh,"\\n");
+      break;
+    case '\\':
+      fprintf(fh,"\\\\");
+      break;
+    default:
+      fprintf(fh,"%c",*(ptr+i));
+    };
+  };
+};
+
+/* This double linked list structure is responsible for storing the dissections from the current packet. Note that we malloc all our memory, but never free it. Nodes in the linked list are reused when necessary. Unused nodes are marked by name=NULL. */
+
+void print_sql_data(FILE *fh, epan_dissect_t *edt) {
+	tvbuff_t *tvb=edt->tvb;
+	int length= tvb_length(tvb);
+	const unsigned char *ptr=tvb_get_ptr(tvb, 0, length);
+
+	fprintf(fh,"INSERT into data set key_id = %u, length = \"%u\", data=\"",frame_no, length);
+	print_sql_string(fh,ptr,length);
+	fprintf(fh,"\";");
+};
+
+static struct protocol_unit *dissected=NULL;
+static struct protocol_unit *current_protocol=NULL;
+
+//Generic constructor for objects: mallocs as much memory as is required and sets it to zero
+void *new_object(int size) {
+  void *new_ptr = (void *)malloc(size);
+  assert(new_ptr != NULL);
+  bzero(new_ptr,size);
+  return (new_ptr);
+};
+
+//Add a new protocol unit to the linked list, and points current_protocol at it.
+struct protocol_unit *add_protocol(char *abbrev) {
+  struct protocol_unit *temp=dissected;
+
+  if(!dissected) {
+    dissected=(struct protocol_unit *)new_object(sizeof(struct protocol_unit));
+    temp = dissected;
+  } else {
+    //Go to the end of the list, or to the point where name is null
+    while(temp &&  temp->name && temp->next) temp=temp->next;
+
+    //If we reach the end, grow the list.
+    if(!temp->next && temp->name) {
+      temp->next=(struct protocol_unit *)new_object(sizeof(struct protocol_unit));
+      temp=temp->next;  
+    };
+  };
+
+  //Store name in current protocol field
+  temp->name = abbrev;
+  current_protocol=temp;
+  return(temp);
+};
+
+/***************************************************
+   Hash table management functions
+**************************************************/
+//Calculates the hash
+t_hash hash(char *name,int size) {
+  t_hash result=0;
+  int i=0;
+
+  while(i<size) {
+    result+=*(t_hash *)(name+i);
+    i+=sizeof(t_hash);
+  };
+
+  return(result);
+};
+
+t_hash edge_hash(struct node_entry *x, struct node_entry *y) {
+  void *a[2];
+  unsigned int i=0;
+  t_hash result=0;
+  a[0] = x;
+  a[1] = y;
+
+  for(i=0; i<2*sizeof(x);i+=sizeof(t_hash)) {
+    result+=*(t_hash *)((char *)a+i);
+  };
+  return result;
+};
+
+//This function runs through the list and sets the name to NULL. Note we do not free the list for efficiency, the list only grows if it needs to, but never shrinks.
+void delete_protocols () {
+  struct protocol_unit *temp = dissected;
+
+  while(temp) {
+    delete_fields(temp);
+    temp->name=NULL;
+    temp=temp->next;
+  };
+
+  current_protocol=dissected;
+};
+
+//This function runs through the list and sets the name to NULL. Note we do not free the list for efficiency, the list only grows if it needs to, but never shrinks.
+void delete_fields(struct protocol_unit *proto) {
+  struct field_unit *temp = proto->field;
+
+  while(temp) {
+    temp->name=NULL;
+    temp->parent=NULL;
+    //   if(temp->value) {
+    //    free(temp->value);
+    //    temp->value=NULL;
+      //  };
+    temp=temp->next;
+  };
+};
+
+//Adds the field into the protocol shown by current_protocol;
+struct field_unit *add_field(char *abbrev,field_info *fi) {
+  struct field_unit *temp=current_protocol->field;
+
+  if(!temp) {
+    current_protocol->field=(struct field_unit *)new_object(sizeof(struct field_unit));
+    temp = current_protocol->field;
+    temp->value=(char *)malloc(ITEM_LABEL_LENGTH*sizeof(char));
+  } else {
+    
+    //Go to the end of the list, or to the point where name is null
+    while(temp &&  temp->name && temp->next ) temp=temp->next;
+
+    //If we reach the end, grow the list.
+    if(!temp->next && temp->name) {
+      temp->next=(struct field_unit *)new_object(sizeof(struct field_unit));
+      temp=temp->next;  
+      temp->value=(char *)malloc(ITEM_LABEL_LENGTH*sizeof(char));
+    };
+  };
+
+  //Store name in current protocol field
+  temp->name = abbrev;
+  if(fi) proto_item_fill_sql_label(fi, temp->value);
+
+  temp->parent=current_protocol;
+  return(temp);
+};
+
+void add_field_str(char *abbrev, char *value){
+  struct field_unit *temp = add_field(abbrev,NULL);
+
+  strncpy(temp->value,value,ITEM_LABEL_LENGTH);
+};
+
+//Expects a null terminated string
+void print_sql_fieldname(FILE *fh, char *name) {
+
+    while(*name) {
+      switch(*name) {
+      case '.':
+	putc('_',fh);
+	break;
+      default:
+	putc(*name,fh);
+      };
+      name++;
+    };
+};
+
+void print_sql_from_dissection() {
+  struct protocol_unit *x = dissected;
+
+  while(x && x->name) {
+    struct field_unit *y = x->field;   
+    printf ("insert into `%s` set key_id = %u",x->name,frame_no);
+
+    while(y && y->name) {
+      printf(",");
+      print_sql_fieldname(stdout,y->name);
+      printf(" = \"");
+      print_sql_string(stdout,y->value,strlen(y->value));
+      printf("\"");
+      y=y->next;
+    };
+
+    printf(";\n");
+    x=x->next;
+  };
+};
+
+char *field_lookup[10];
+
+//Superfast array searches....
+//Note that we are _not_ doing string comparisons, only pointer comparisons. This work because we expect the strings passed in to be the initialized versions from kb_init. We rely on the dissector hfinfo to remain statically in memory throughout program execution (i.e. not be reinitialized). If start is nonNull, we start searching at start.
+struct field_unit *find_field(const char *protocol, const char *field,struct protocol_unit* start) {
+  struct protocol_unit *x=dissected;
+  struct field_unit *y;
+
+  if(start) {
+    if(!start->next) return NULL;
+    x=start->next;
+  };
+
+  assert(protocol);
+  assert(field);
+  //First find the protocol we are looking for
+  while(x && x->name && x->name != protocol) {
+    x=x->next;
+  };
+  
+  //Could not find the protocol.
+  if(!x) return(NULL);
+
+  //Search for the field.
+  y = x->field;   
+  while(y && y->name) {
+    //Got it....
+    if(y->name==field) return(y);
+    
+    y=y->next;
+  };
+  
+  //Could not find the field
+  return NULL;
+};
+
+
+//Adds a node to the node table. Note - caller must malloc name and value and must not free those. This object's destructor will free name and value (currently we never need to destroy these objects because we do not delete from the node table).
+struct node_entry *add_node(char *type,char *name, char *value) {
+  struct node_entry *temp = node_table;
+  t_hash temp_hash;
+
+  if(!node_table) {
+    node_table=(struct node_entry *)new_object(sizeof(struct node_entry));
+    node_table_end=node_table;
+    temp=node_table;
+  } else {
+    //    while(temp && temp->next ) temp=temp->next;
+    temp = node_table_end;
+    temp->next = (struct node_entry *)new_object(sizeof(struct node_entry));
+    temp = temp->next;
+    node_table_end = temp;
+  };
+  
+  temp->type = type;
+  temp->name = name;
+  temp->value = value;
+
+  //Add node to hash index: This assumes that the node does not exist already in the node table.
+  temp_hash = hash(name,strlen(name));
+  
+  // If we dont have this hash in the table yet 
+  if(node_hashes[temp_hash] == NULL) {
+    node_hashes[temp_hash] = (struct hash_link *)new_object(sizeof(struct hash_link));
+    node_hashes[temp_hash]->node = temp;
+  } else {
+    //We already have this hash in the table: go to the end of the list and add a new link
+    struct hash_link *temp_hl = node_hashes[temp_hash];
+    while(temp_hl && temp_hl->next) temp_hl=temp_hl->next;
+    temp_hl->next = (struct hash_link *)new_object(sizeof(struct hash_link));
+    temp_hl->next->node = temp;
+  };
+  
+  printf("insert into knowledge_node set type='%s',name='%s',value='%s',packet='%u';\n",type,name,value,frame_no);
+  return(temp);
+};
+
+//Adds a new edge to the edge table
+struct edge_entry *add_edge(char *field,struct node_entry *from, struct node_entry *to,char *description,enum transitive_en transitive) {
+  struct edge_entry *temp = edge_table;
+  char *tmp;
+  t_hash temp_hash;
+
+  if(!from || !to) return NULL;
+
+  if(!edge_table) {
+    edge_table=(struct edge_entry *)new_object(sizeof(struct edge_entry));
+    temp=edge_table;
+    edge_table_end = temp;
+  } else {
+    //    while(temp && temp->next ) temp=temp->next;
+    temp=edge_table_end;
+    temp->next = (struct edge_entry *)new_object(sizeof(struct edge_entry));
+    temp = temp->next;
+    edge_table_end = temp;
+  };
+  
+  temp->field=field;
+  temp->from = from;
+  temp->to = to;
+  temp ->description = description;
+  temp ->transitive = transitive;
+
+  //Add edge to hash index: 
+  temp_hash = edge_hash(from,to);
+  
+  // If we dont have this hash in the table yet 
+  if(edge_hashes[temp_hash] == NULL) {
+    edge_hashes[temp_hash] = (struct hash_link *)new_object(sizeof(struct hash_link));
+    edge_hashes[temp_hash]->edge = temp;
+  } else {
+    //We already have this hash in the table: go to the end of the list and add a new link
+    struct hash_link *temp_hl = edge_hashes[temp_hash];
+    while(temp_hl && temp_hl->next) temp_hl=temp_hl->next;
+    temp_hl->next = (struct hash_link *)new_object(sizeof(struct hash_link));
+    temp_hl->next->edge = temp;
+  };
+
+  if(transitive == TRANSITIVE) {
+    tmp="transitive";
+  } else {
+    tmp="no";
+  };
+
+ // if(!field) return(temp);
+  printf("insert into knowledge set field='%s',packet='%u',name='%s',pname='%s',description='%s',link='%s';\n",field,frame_no,from->name,to->name,description,tmp);
+  return(temp);
+};
+
+//Searches the node table untill it finds a node of the given name, returns it. 
+struct node_entry *find_node(char *name) {
+  t_hash temp_hash = hash(name,strlen(name));
+
+  if(node_hashes[temp_hash]) {
+    struct hash_link *temp = node_hashes[temp_hash];
+
+    do {
+      if(temp->node && !strcmp(name,temp->node->name)) return(temp->node);
+      temp=temp->next;
+    } while(temp);
+  };
+  
+  return NULL;
+};
+
+//Searches the edge table for an edge from *from to *to. FIXME: To be implemented by a hash table
+struct edge_entry *find_edge(struct node_entry *from, struct node_entry *to) {
+  t_hash temp_hash = edge_hash(from,to);
+  
+   if(edge_hashes[temp_hash]) {
+    struct hash_link *temp = edge_hashes[temp_hash];
+
+    do {
+      if(temp->edge && temp->edge->from == from && temp->edge->to == to) return(temp->edge);
+      temp=temp->next;
+    } while(temp);
+  };
+  
+  return NULL;
+};
+
+void create_name(char *name,char *name1,char *name2, char *name3, char *name4) {
+  int i=0;
+
+  if(name1) {
+    i=strlen(name1);
+    strncpy(name, name1,i);
+  };
+  if(name2) {
+    strncpy(name+i,name2,MAX_NODE_NAME_LEN-i);
+    i+=strlen(name2);
+  };
+  if(name3) {
+    strncpy(name+i,name3,MAX_NODE_NAME_LEN-i);
+    i+=strlen(name3);
+  };
+  
+  if(name4) {
+  strncpy(name+i,name4,MAX_NODE_NAME_LEN-i);
+  i+=strlen(name4);
+  };
+  name[i]=0;
+}
+
+void edge_set_from(char *type,char *value,char *name1,char *name2, char *name3, char *name4) {
+  char name[MAX_NODE_NAME_LEN];
+
+  create_name(name,name1,name2,name3,name4);
+  //Check to see if this node is in the node table, if not create a new one - either way we return with a ready node object in from.
+  if(value) {
+    if(!(test_edge->from=find_node(name))) {
+      test_edge->from=add_node(type,strdup(name),strdup(value));
+    };
+  };
+  
+};
+
+
+void edge_set_to(char *type,char *value,char *name1,char *name2, char *name3, char *name4) {
+  char name[MAX_NODE_NAME_LEN];
+
+  create_name(name,name1,name2,name3,name4);
+  //Check to see if this node is in the node table, if not create a new one - either way we return with a ready node object in to.
+  if(value) {
+    if(!(test_edge->to=find_node(name))) {
+      test_edge->to=add_node(type,strdup(name),strdup(value));
+    };
+  };
+  
+};
+
+void edge_swap_to_from () {
+  struct node_entry *temp;
+
+  temp=test_edge->to;
+  test_edge->to = test_edge->from;
+  test_edge->from = temp;
+};
+
+void edge_set_link(char *field,char *description,enum transitive_en transitive) { 
+  if(!find_edge(test_edge->from,test_edge->to)) {
+    add_edge(field,test_edge->from,test_edge->to,description,transitive);
+  };
+};
+
+
+//Note: We assume that ip_to_str will not return more then MAX_IP_SIZE chars
+char *field_ip_to_str(char *field,char *temp) {
+	guint32 h_addr = atoll (field);
+	guint32 n_addr;
+
+	n_addr = htonl(h_addr);
+	snprintf(temp, MAX_NODE_NAME_LEN-1,
+		 "%s", ip_to_str((guint8*)&n_addr));
+	
+	return(temp);
+};
+
+//Makes deductions from the given set of data.
+void make_deductions() {
+  struct field_unit *temp,*temp2,*temp3,*temp4,*temp5,*temp6;
+  struct protocol_unit *x;
+  char tmpstr[MAX_NODE_NAME_LEN];
+  char t1[MAX_IP_SIZE];
+ 
+  //Relate mac address to IP address.
+  temp = find_field(kb_ptr[IP],kb_ptr[IP_SRC],NULL);
+  temp2 = find_field(kb_ptr[ETH],kb_ptr[ETH_SRC],NULL);
+  
+  if(temp && temp2) {
+    field_ip_to_str(temp->value,t1);
+
+    edge_set_from("ip_addr",t1,"ip:",t1,NULL,NULL);
+    edge_set_to("eth_add",temp2->value,"eth:",temp2->value,NULL,NULL);
+    
+    //We ignore ICMP packets, since they confuse the issue
+    if(!find_field(kb_ptr[ICMP],kb_ptr[ICMP_TYPE],NULL))  {
+      edge_set_link("eth_src","IP Address",NO);
+    };
+
+  };
+  
+  //Listening TCP connections:
+  temp3 = find_field(kb_ptr[TCP],kb_ptr[TCP_SRCPORT],NULL);
+  temp4 = find_field(kb_ptr[TCP],kb_ptr[TCP_FLAGS],NULL);
+  if(temp4 && temp3 && temp) {
+    edge_set_to("ip_addr",t1,"ip:",t1,NULL,NULL);
+    
+    if(!strcmp(temp4->value,"18")) {
+      edge_set_from("listening_tcp_port",temp3->value,"LT_",temp->value,":",temp3->value);
+      edge_set_link("tcp_srcport","Listening on port",NO);
+
+      //Transitive TCP connections (between objects)
+      temp2=find_field(kb_ptr[IP],kb_ptr[IP_DST],NULL);
+      if(temp2) {
+	char t2[MAX_IP_SIZE];
+	field_ip_to_str(temp2->value,t2);
+
+	create_name(tmpstr,"Syn:",temp3->value,NULL,NULL);
+
+	edge_swap_to_from();
+	edge_set_to("ip_addr",t2,"ip:",t2,NULL,NULL);
+	edge_set_link("tcp_srcport",strdup(tmpstr),TRANSITIVE);
+	edge_swap_to_from();
+      };
+      
+      //Rejected TCP ports
+    } else if(!strcmp(temp4->value,"20")) {
+      edge_set_from("closed_tcp_port",temp3->value,"CTP_",temp->value,":",temp3->value);
+      edge_set_link("tcp_srcport","Not Listening on port",NO);
+    };
+
+  };
+
+  //DNS Records: A first, then other records as needed:
+  x=NULL;
+  //We are searching for multiple records in each dns packet
+  while((temp5 =  find_field(kb_ptr[DNS_DATA],kb_ptr[DNS_NAME],x))) {
+    temp6=find_field(kb_ptr[DNS_DATA],kb_ptr[DNS_TYPE],x);
+    temp2=find_field(kb_ptr[DNS_DATA],kb_ptr[DNS_DATA_DATA],x);
+
+    if(temp2 && temp6) {
+      if(!strcmp(temp6->value,"A")) {
+	edge_set_from("dns_A",temp5->value,"A:",temp5->value,NULL,NULL);
+	edge_set_to("ip_addr",temp2->value,"ip:",temp2->value,NULL,NULL);
+	edge_set_link("dns_data.name","DNS A Record ",NO);
+      } else {
+	create_name(tmpstr,"dns_",temp6->value,NULL,NULL);
+	edge_set_from(strdup(tmpstr),temp5->value,temp6->value,":",temp5->value,NULL);
+	edge_set_to("dns_A",temp2->value,"A:",temp2->value,NULL,NULL);
+
+	create_name(tmpstr,"DNS ",temp6->value," Record",NULL);
+	edge_set_link("dns_data.name",strdup(tmpstr),NO);
+      };
+    };
+    x=temp5->parent;    
+  };
+
+  //POP user analysis:
+  temp5=find_field(kb_ptr[POP],kb_ptr[POP_REQ_COMMAND],NULL);
+  if(temp5 && !strcasecmp(temp5->value,"USER")) {
+    temp6=find_field(kb_ptr[POP],kb_ptr[POP_REQ_PARAMETER],NULL);
+    if(temp6) {
+      edge_set_from("pop_user",temp6->value,"POPUser:",temp6->value,NULL,NULL);
+      edge_set_to("ip_addr",t1,"ip:",t1,NULL,NULL);
+      edge_set_link("pop.req.parameter","POP Username",NO);
+    };
+  };
+};
+
diff -Naur ethereal-0.9.16/sql.h ethereal-0.9.16_new/sql.h
--- ethereal-0.9.16/sql.h	1970-01-01 10:00:00.000000000 +1000
+++ ethereal-0.9.16_new/sql.h	2003-11-26 19:29:36.000000000 +1100
@@ -0,0 +1,125 @@
+/* sql.c
+ * This file is part of a patch to generate SQL automatically from TCPDUMP
+ *
+ * Michael Cohen michael.cohen@netspeed.com.au
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __SQL_H__
+#define __SQL_H__
+
+#define MAX_NODE_NAME_LEN 100
+#define MAX_IP_SIZE 20
+
+struct protocol_unit {
+  char *name;
+  struct field_unit* field;
+  struct protocol_unit *next;
+};
+
+struct field_unit {
+  char *name;
+  char *value;
+  struct protocol_unit *parent;
+  struct field_unit *next;
+};
+
+void print_sql_string(FILE *fh, const unsigned char *ptr, int length);
+void print_sql_data(FILE *fh, epan_dissect_t *edt);
+struct protocol_unit *add_protocol(char *abbrev);
+void *new_object(int size);
+struct node_entry *add_node(char *type,char *name, char *value);
+
+void delete_protocols ();
+struct field_unit *add_field(char *abbrev,field_info	*fi);
+void add_field_str(char *abbrev, char *value);
+void delete_fields (struct protocol_unit *proto);
+void init_kb_ptr();
+extern char *kb_ptr[];
+
+extern gchar        post[ITEM_LABEL_LENGTH];
+extern int             frame_no;
+extern GString *additional_sql;
+
+extern gboolean print_sql;               //Shall we emit sql statements?
+extern gboolean print_knowledge;  //Shall we emit knowledgebase statements?
+
+extern struct property* gprop;
+
+#define MAX_KB_PTR 100
+
+enum kb_fields_enum {
+  ETH_SRC=0,
+  ETH_DST,
+  IP_SRC,
+  IP_DST,
+  ETH,
+  IP,
+  ICMP_TYPE,
+  ICMP,
+  TCP,
+  TCP_SRCPORT,
+  TCP_FLAGS,
+  DNS,
+  DNS_DATA,
+  DNS_DATA_DATA,
+  DNS_NAME,
+  DNS_TYPE,
+  POP,
+  POP_REQ_COMMAND,
+  POP_REQ_PARAMETER
+};
+
+/* The knowledge base consists of 2 tables: a node table and an edge table. Each table consists of a set of linked lists */
+
+struct node_entry {
+  char *type;
+  char *name;
+  char *value;
+  struct node_entry *next;
+};
+
+struct edge_entry {
+  char *field;
+  int packet;
+  struct node_entry *from;
+  struct node_entry *to;
+  char *description;
+  enum transitive_en {
+    NO, TRANSITIVE
+  } transitive;
+  struct edge_entry *next;
+};
+
+struct edge_entry *add_edge(char *field,struct node_entry *from, struct node_entry *to,char *description,enum transitive_en transitive);
+
+//This section relates to hash tables (needs to be unsigned)
+typedef unsigned short int t_hash;
+//Make this the size of t_hash above
+#define SIZE_OF_HASHTABLE 65536
+
+struct hash_link {
+  struct node_entry *node;
+  struct edge_entry *edge;
+  struct hash_link *next;
+};
+
+
+#endif /* sql.h */
diff -Naur ethereal-0.9.16/tethereal.c ethereal-0.9.16_new/tethereal.c
--- ethereal-0.9.16/tethereal.c	2003-11-03 04:15:21.000000000 +1100
+++ ethereal-0.9.16_new/tethereal.c	2003-11-26 19:27:45.000000000 +1100
@@ -81,6 +81,7 @@
 #include "column.h"
 #include "print.h"
 #include <epan/resolv.h>
+#include "sql.h"
 #include "util.h"
 #ifdef HAVE_LIBPCAP
 #include "pcap-util.h"
@@ -813,11 +814,13 @@
      "-G" flag, as the "-G" flag dumps information registered by the
      dissectors, and we must do it before we read the preferences, in
      case any dissectors register preferences. */
+  init_kb_ptr();
+
   epan_init(PLUGIN_DIR,register_all_protocols,register_all_protocol_handoffs);
 
   /* Register all tap listeners; we do this before we parse the arguments,
      as the "-z" argument can specify a registered tap. */
-  register_all_tap_listeners();
+//  register_all_tap_listeners();
 
   /* Now register the preferences for any non-dissector modules.
      We must do that before we read the preferences as well. */
@@ -836,9 +839,13 @@
     else {
       if (strcmp(argv[2], "fields") == 0)
         proto_registrar_dump_fields();
-      else if (strcmp(argv[2], "protocols") == 0)
+      else if (strcmp(argv[2], "protocols") == 0) {
         proto_registrar_dump_protocols();
-      else {
+    } else if(!strcmp(argv[2],"sql")) {
+        proto_registrar_dump_sql(1);
+    } else if(!strcmp(argv[2],"drop")) {
+        proto_registrar_dump_sql(0);
+    } else {
         fprintf(stderr, "tethereal: Invalid \"%s\" option for -G flag\n",
                 argv[2]);
         exit(1);
@@ -910,7 +917,7 @@
   get_runtime_version_info(runtime_info_str);
 
   /* Now get our args */
-  while ((opt = getopt(argc, argv, "a:b:c:d:Df:F:hi:lLnN:o:pqr:R:s:St:vw:Vxy:z:")) != -1) {
+  while ((opt = getopt(argc, argv, "a:b:c:d:Df:F:hi:lLnN:o:pqr:R:s:St:vw:VKQxy:z:")) != -1) {
     switch (opt) {
       case 'a':        /* autostop criteria */
 #ifdef HAVE_LIBPCAP
@@ -1191,6 +1198,15 @@
         arg_error = TRUE;
 #endif
         break;
+	/* Prints SQL insert statements instead */
+    case 'Q':
+	    print_sql = TRUE;
+	    verbose=TRUE;
+	    break;
+    case 'K':
+      print_knowledge = TRUE;
+      verbose=TRUE;
+      break;
       case 'z':
         for(tli=tap_list;tli;tli=tli->next){
           if(!strncmp(tli->cmd,optarg,strlen(tli->cmd))){
@@ -2508,7 +2524,7 @@
       print_args.expand_all = TRUE;
       print_args.print_only_marked = FALSE;
       proto_tree_print(&print_args, edt, stdout);
-      if (!print_hex) {
+      if (!print_hex && !print_sql && !print_knowledge) {
         /* "print_hex_data()" will put out a leading blank line, as well
 	   as a trailing one; print one here, to separate the packets,
 	   only if "print_hex_data()" won't be called. */
@@ -2697,12 +2713,18 @@
       }
       putchar('\n');
     }
+
     if (print_hex) {
-      print_hex_data(stdout, print_args.format, edt);
-      putchar('\n');
+      if(print_sql) {
+	print_sql_data(stdout, edt);
+	//	putchar('\n');
+      } else {
+	print_hex_data(stdout, print_args.format, edt);
+	putchar('\n');
+      }
     }
   }
-
+    
   /* The ANSI C standard does not appear to *require* that a line-buffered
      stream be flushed to the host environment whenever a newline is
      written, it just says that, on such a stream, characters "are
