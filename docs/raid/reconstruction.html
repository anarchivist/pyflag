<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Raid Reassembly - A forensic Challenge</title>
  </head>

  <body>
    <h1>Raid Reassembly - A forensic Challenge</h1>
    <b>Scudette@users.sourceforge.net</b>
<h2>Abstract</h2>
    When Forensic examiners and Incident response teams seize a computer system, quite often Raid Drives are involved. Raid arrays are now commonly found on many computers - from the expensive enterprise server machines, all the way to desktop machines. Imaging these machines is often a problem by the forensic examiner since reconstituting these images in the lab may be difficult without the identical raid controller used to create the array, and an identical configuration. Sometimes the controller may not accept the disks as members of the array if the array header is damaged or overwritten.<p>
This paper covers the manual reconstruction of raid sets. A method is presented to manually recover the raid reconstruction map, and tools are presented to use this map for reassembling the original raid set or simply use the entire set as evidence without reassembly.
<h2>Introduction</h2>
Raid disks have become popular in the past couple of years even in low end systems. When confronted with a raid system, the investigator is often confronted with a difficult choice. 

One reliable way for imaging this system is to attempt booting the system from a CDROM into a forensic platform such as KNOPPIX or FIRE for example. These platforms have drivers for many raid controller which would often allow the array to be seen as a single logical disk. Then the investigator would image the device over the network, USB or FireWire to another machine. 

The above method is very reliable and certainly should be used as the first port of call. However, often this method fails:
    <ul>
      <li>Often the drivers present in the forensic operating system do not support the raid controller. If the controller does not have native Linux support this might be a problem. </li>
      <li>The Raid is done in software using a proprietary product. There are no Linux drivers that are capable of reading such an array.</li>
      <li>The headers on the disks are damages or the disks are marked as bad, leading the array controller to refuse to use these disk, despite the fact that the disks themselves might be readable.</li>
      <li>It is impossible to obtain the original controller and BIOS configuration. This might happen if the controller has been destroyed or is simply unavailable.</li>
</ul>

    In these cases the raid will have to be reconstructed by hand. This paper will detail a method to allow this process to be done reliably.
<h2>Raid Overview</h2>
Raid arrays are commonly found in a number of configurations. The following is simply a brief overview of some of the common configurations, although other configurations are possible, these are the most common. All configurations strike a balance between speed storage space and redundancy.
<h3>Raid 0</h3>
    The Raid 0 (stripping) configuration does not provide any redundancy. It aims to increase the speed and space provided by the array. Data is stripped across all the disks, with consecutive blocks on consecutive disks:<br>
<img  height=480 width=640 src=raid0.png><p>
The diagram above shows how blocks are distributed among the disks in the array. As can be seen, the logical blocks are distributed sequentially through all the disks at the same physical block address. Hence the Raid 0 configuration provides n times the space storage (when n is the number of disks in the array). Write and read speed are also increased n fold as consecutive blocks may be stored in different disks simultaneously.
<h3>Raid 1</h3>
    This configuration (mirroring) is designed to provide redundancy rather than storage or speed. The block allocation is shown in the figure:<br>
<img  height=480 width=640 src=raid1.png><p>
Logical blocks are copied to each disk separately. Hence if a disk is lost, the block may be recovered from one of the other disks. The configuration provides redundancy but uses n times the logical storage provided in hard disk space. This configuration also provides an n fold increase in sequential reading speed, since sequential blocks may be read simultaneously, but does not offer improvement in writing speed. <p>
<h3>Raid 5</h3>
This configuration strikes a balance between redundancy and space. The redundancy is provided by using a parity block which is moved around the array in a specific pattern. The parity block is generated by taking performing an xor operation on all other physical blocks in the array:<br>
<img  height=480 width=640 src=raid5.png><p>
Performing an Xor operation of all the blocks at the same physical block location will result in 0. If one of the disks fail, its contents may be reconstructed by xoring all the other disks together.
<p>
Although the above description seems simple enough, the actual striping pattern on the disks is often different and implementation dependant. Further, the order of the disks may be unknown or completely different from the order with which the disks are labelled on the front of the machine. These factors contribute to making raid reconstruction a more complex task.
<h2>Definitions</h2>
In this paper we concentrate on reconstructing Raid 5. Raid 0 reconstruction is analogous (except there is no parity to consider), while Raid 1 is trivial (simply take one of the disks). The following set of definitions is used:<p>
    <dl>
      <dt>Block,</dt>
      <dt>Block size</dt>
      <dd>A unit storing contiguous data. The Block is the basic unit used by the controller. Data within the block is contiguous. Blocks are usually multiples of 512 bytes (often 4k - 64k). The block size is the size in bytes of this unit. The block size is common to both logical blocks and physical blocks.</dd>
      <dt>Logical Block</dt>
      <dd>A logical block refers to the logical data stored on the array. Logical blocks represent contiguous logical data, but will be physically stored on different disks at different physical block locations.</dd>
      <dt>Physical Block</dt>
      <dd>Physical blocks reside on the disks. Physical block numbers are consecutive on the disk, but do not represent consecutive data within the logical data stream. For example, in the Raid 5 diagram above, the physical block 1 for disk 1 is said to store logical block 2.</dd>
      <dt>Parity Block</dt>
      <dd>A special type of block obtained by taking the Xor operation of all logical blocks found at the same physical block number on all the disks.</dd>
      <dt>Striping Map</dt>
      <dd>This is a map relating logical block numbers to physical block number and disk number tuples. For example in the Raid-5 figure above the map would start 0=>(0, disk 1), 1=>(0,disk 2) etc..</dd>
      <dt>Physical Array period,</dt>
      <dt>Logical Array Period</dt>
      <dd>All Raid implementations use repeatable patterns for their Striping maps. The physical period is the number of physical blocks used before that pattern is repeated, while the logical period is the total number of logical blocks that will fit within a physical period. For example, in the Raid-5 figure above, if the next physical block (3) was: 6,7,P(6+7), it would be exactly the same as physical block 0, and hence the physical period would be 3, while the logical period would be 5.</dd>
      <dt>Slot</dt>
      <dd>A slot represent a relative physical block within the period. That is, the slot is the remainder after dividing the Physical block with the period. Since the Striping Map repeats with the array period, a slot represents a sequence of physical blocks an integer number of array periods apart. For the example above, the slot 1 would represent physical blocks 1,4,7,10... Slots allow us to compress the Striping Map to the period length. The striping map is therefore represented as a table with as many columns as disks, as many rows as the physical period length and logical blocks numbered in the table cells (see examples above).</dd>
      <dt>
    </dl>

    <h2>Reassembling the Raid</h2>
    In order to reassemble the array, it is necessary to follow this rough order of tasks:
    <ol>
      <li>Find the block size.</li>
      <li>Determine the physical array period by following the parity blocks around the disks.</li>
      <li>Construct the Striping map by inspecting which physical blocks follow each other throughout the image. Reinforce this observation by looking at different physical blocks representing the same slot position.</li>
      <li>Often reordering the disks will produce a much more obvious pattern in the striping map. This pattern will allow the investigator to guess the complete pattern without having to confirm each element in the map</li>
      <li>Reassemble the map, attempting to recover useful data from the array. If the map is correct the reassembled array will be error free.</li>
    </ol>

    <h2>Example</h2>
    The following case study can be used to illustrate the process. This case involves a 7 member Raid-5 implementation. The 
    <hr>
    <address><a href="mailto:scudette@users.sourceforge.net"></a></address>
<!-- Created: Sun Sep 12 18:10:16 EST 2004 -->
<!-- hhmts start -->
Last modified: Sun Sep 12 23:15:08 EST 2004
<!-- hhmts end -->
  </body>
</html>
