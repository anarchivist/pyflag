<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.5: http://docutils.sourceforge.net/" />
<title>PyFlag Manual</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<h1 class="title">PyFlag Manual</h1>
<div class="document" id="pyflag-manual">
<p>Flag (Forensic and Log Analysis GUI) is a tool designed to simplify the examination of forensic evidence in the form of Hard disk images, logs and network captures. This manual documents some of the basic aspects of FLAG, but is by no means complete. There is a complete API documentation produced by epydoc in the docs directory. The API documentation is designed for developers who wish to contribute to PyFlag development.</p>
<div class="section" id="basic-concepts">
<h1><a name="basic-concepts">Basic Concepts</a></h1>
<p>The following section describes a number of basic concepts in PyFlag.</p>
<div class="section" id="flag-cases">
<h2><a name="flag-cases">Flag Cases</a></h2>
<p>A central concept to flag is the case. A case is simply an area to collect related information regarding a particular incident. Internally a case is kept in its own database, and tables are added to the case as different forms of evidence are added.</p>
<p>To create a new case, click the Case Management tab and add a new case.</p>
<p>Resetting the case deletes all data from the case, which is essentially equivalent to dropping the case database and recreating it.</p>
</div>
<div class="section" id="io-sources">
<h2><a name="io-sources">IO Sources</a></h2>
<p>Another central concept to FLAG is the IO source. An IO source is simply a way of specifying a source of data for flag. The concept of IO Source is an abstraction of data sources. For example, a hard disk image is a source of data, however we could use a number of different types of hard disk images, e.g. dd images, encase evidence files etc.</p>
<p>Hence FLAG uses an IO source to handle data, and the specifics of how to access this form of data are abstracted. IO Sources are currently heavily utilised in the disk forensic module, but may be extended to other modules in the future. Although the following examples are concentrating on hard disk images, in the future similar IO Subsystems will be used for other aspects of FLAG, such as log files, and network captures.</p>
<p>The following IO Source types are currently supported. Other IO sources may be added in the future:</p>
<ul>
<li><p class="first">Standard</p>
<p>The Standard IO Source is the most basic. It represents a simple linear file stored on disk. For example this might be a dd image of a partition, ready to load directly into FLAG.</p>
<p>In order to take a standard forensic image suitable to be imported into flag, do this for example (Note that we must take a dd image of a partition, not an entire hard disk):</p>
<pre class="literal-block">
dd if=/dev/hda1 of=image.dd
</pre>
</li>
<li><p class="first">Advanced</p>
<p>The advanced IO Source allows the image to be split into mutiple files. We can also specify an offset into the image to start analysing from. This allows us to analyse a dd image of an entire hard disk. For example:</p>
<pre class="literal-block">
dd if=/dev/hda of=image.dd
</pre>
<p>We can find the offset of the partition (we need to specify for FLAG) in the image by doing:</p>
<pre class="literal-block">
sfdisk -luS /dev/hda
</pre>
</li>
<li><p class="first">SGZIP</p>
<p>With todays very large hard disks it is sometimes difficult to manipulate dd images. Since dd images are uncompressed, when analysing a 120GB hard disk (which is now commodity on most PCs), the analysis platform must be able to handle a single 120GB file, which may need to be archived etc.</p>
<p>Many people archive very large dd images by using a standard compression program such as gzip or bzip2. This helps the archive of the file, but it is impossible to directly use the compressed file in the analysis without decompressing it first. The main reason for this is because most general purpose compression formats are not designed for seeking randomly through the file.</p>
<p>Most industry standard forensic packages provide a method for manipulating compressed hard disk images directly. FLAG supports a number of different formats at this time namely sgzip, and eyewitness compression format (which is mainly used by Encase(tm), and FTK(tm)).</p>
<p>The sgzip format is based on gzip, but provides a seekable capability. This is achieved by compressing blocks (default size of 32kb) individualy. Then a seek operation simply needs to locate the right 32kb block and decompress that. The specific details of the file format are found in the file sglib.h.</p>
<p>Sgzip is a robust format, which means that if the image file is damaged in some way (e.g. some of it is corrupted, or truncated) it is still possible to retrieve most of the data from within it (contrast this with for example Encase, which can not recover from a corrupted evidence file). To create an sgzip file, use the supplied sgzip utility:</p>
<pre class="literal-block">
  dd if=/dev/hda | sgzip -v &gt; image.sgz

It is also possible to decompress the sgzip file back into a regular dd image::

  sgzip -vd image.sgz
</pre>
</li>
<li><p class="first">EWF (Eye Witness Format)</p>
<p>Eye witness format is a proprietary format which is mainly used by Encase and FTK. This format also compresses data in 32kb chunks to achieve a seekable compressed file. This file format must also be split across files smaller than 2gb (generally 640mb is used).</p>
<p>Although FLAG can also create EWF files, at this stage they are not (yet) readable by Encase. It is perfectly valid to generate EWF files using FLAG for usage within FLAG, however since the EWF format is fragile (i.e. can not tolerate corruption), this is not recommended and it is better to use sgzip for this purpose. The other major disadvantage of the EWF format is that it is impossible to write an EWF file into a pipe. Hence it is not possible to image over the network (using netcat for example). Sgzip is a better format choice here as well.</p>
<p>Most of the time FLAG is used to analyse images taken using encase, or to repair corrupted encase images (The flag ewf implementation is quite flexible and can be used to repair encase images, whereas encase itself will not import those in most cases). See the evtool for examples of how EWF images can be manipulated. To use EWF images in FLAG simply select all the files (with extension .E01,.E02 etc) files in the IO Sources.</p>
</li>
<li><p class="first">Mounted</p>
<p>PyFlag uses &lt;a href=http://www.sleuthkit.org&gt;The Sleuthkit&lt;/a&gt; as the underlying engine for reading filesystems. The Sleuthkit supports a number of filesystems, but not as many as are generally available using the Linux kernel to mount filesystems. To fill in the shortfall the Mounted IO Source is designed to incorporate the contents of a directory (or a mount point) within PyFlag. There are a number of critical points to note when using the Mounted IO Source:</p>
<ul>
<li><p class="first">The Linux kernel filesystem driver does not know or care about deleted Inodes. It is not designed for forensic work, so it is impossible to recover deleted files with mounted filesystems.</p>
<p>Mounting a filesystem is a privileged operation. Typical only root is allowed to mount the filesystem.</p>
<p>Since the filesystem may contain files with ownerships preventing regular users from accessing those files, it is best to run PyFlag as the root user when using the Mounted IO Source. This is the only time when running PyFlag as a privileged user is necessary, and usually this practice is discouraged.</p>
<p>Since PyFlag is not responsible for actually mounting the filesystem, it is completely the user's responsibility that the filesystem is mounted sensibly, i.e. mounted read only (watch out for journaling filesystems modifying images even when mounted read only). It is recommended that the user perform an md5 sum of the image before and after mounting it.</p>
<p>Clearly since the linux kernel does not support sgzip, or EWF, or split dd images, the image files must be simple raw dd images (possibly with an offset specified) which are understood by the loop driver.</p>
<p>Since a Mounted IO Source is not a real IO Source, there are some limitations with using this IO Source. Namely, certain reports that need access to the raw device will not work, for example Extract Files and Indexing. It is recommended that a seperate IO Source representing the raw device be used for these purposes.</p>
<p>The Mounted IO Source can be used to analyse CDROM images (ISO9660), which are not currently supported by Sleuthkit. Even NFS mounts, or SMB mounts can be analysed in this way, if physical access to the hard disk is not possible.</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="table-viewer-widget-and-the-navigation-bar">
<h2><a name="table-viewer-widget-and-the-navigation-bar">Table Viewer Widget and the Navigation Bar</a></h2>
<p>The most powerfull widget in flag is the table viewer. This widget allows for extremely sophisticated searching of the dataset and is so important that an entire section is dedicated to it here. The figure below shows a typical usage of the <em>Table widget</em>, although it is used in many places within PyFlag.</p>
<p>The Table widget is shown here.</p>
<div class="figure">
<p align="center"><img align="center" alt="images/Table.eps" src="images/Table.eps" /></p>
<p class="caption">The PyFlag Table widget with captions explaining the different functions.</p>
</div>
<p>The following components can be seen:
- Current Case:</p>
<blockquote>
This shows the currently selected case name</blockquote>
<ul>
<li><p class="first">Next and Previous Page:</p>
<p>Often the number of rows of data can not fit within a single screen full. In this case the Next page arrow will be unshaded indicating that another page is available to view.</p>
</li>
<li><p class="first">Main Menu:</p>
<p>The menu button takes you directly to the main menu for the currently selected module. From there you may select another module to look at or simply another report.</p>
</li>
<li><p class="first">Column Name:</p>
<p>Each column in the table has a name. Clicking on the column name indicates that you wish to order the result alphabetically by that column. At any one time, a single column will appear to have a pink background. This indicates that the result is ordered by this column. Clicking the column again flips the sense of the ordering (from ascending to descending and back again).</p>
<p>Note the colouring of the rows alternating between gray and white. For each unique value of the ordering column these colours alternate. The result is that by ordering the result set on one of the columns, it is quick to see which rows contain identical values with each column, because they will appear like groups of different colours.</p>
</li>
<li><p class="first">Group by Column:</p>
<p>The Group by column allows the user to count how many entries in the result set occur with each value of the column. For example in the figure above, by grouping by Source IP (and ordering by counts), it is possible to see which source IP produced the greatest number of hits.</p>
<p>Once in the group by screen, clicking on the individual source IP address allows the user to view all the hits produced by that IP address.</p>
<p>Within the group by screen it is possible to plot a graph of the most common entries in the grouped by column. This is useful to gain a rapid visual feel to the data.</p>
</li>
<li><p class="first">Search Column:</p>
<p>It is often handy to be able to eliminate a subset of the result set from the table, and concentrate on those results which match a specific criteria. For example, we may want to see those hits produced between certain date range, or those IP addresses requesting certain file extensions, or possibly both conditions at once.</p>
<p>The search capability within the table widget allows for complex search criteria to be performed. Conditions are added cumulatively with a logical &quot;and&quot; seperating them. So for example, you can add the condition date&gt;2001-10-01 and date&lt;2002-10-01. The query is entered into the text area where the sense of the query is determined by the first character of the query string. So for example typing &quot;&lt;2001-10-01&quot; in the date column will show all dates prior to october 1st 2001. The following modifiers are supported:
- &gt; - The values are greater than the specified value
- &lt; - The values are less than the specified value
- = - The values are exactly equal to the specified value
- ! - The values are not equal to the specified value
- Search term with a % in it - The values are similar to the specified value with % being the wildcard
- Search term - The values are similar to the specified value with wildcards automatically added before and after the search terms (so it may match in the middle of the entry)</p>
</li>
</ul>
<p>Note that as new searching conditions are added, they will be listed at the top of the table. You may click on any of those links to remove that search term, while still preserving the others.</p>
<ul>
<li><p class="first">ToolBar:</p>
<p>These icons represent extra functions that may be invoked on the table widget:</p>
<ul class="simple">
<li>Customise Table: This allows the hiding of selected columns. This is usefull when the table has many columns or when exporting the data.</li>
<li>Export Data: After selecting the required subset of the data, it is often useful to extract the relevant data for insertion into a different application (e.g. into a report). This function allows the data to be exported into a comma delimited file (CSV) which may be imported into most spreadsheet programs.</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="modules">
<h1><a name="modules">Modules</a></h1>
<p>PyFlag has an extensible, open architecture which allows developers to add arbitrary modules to the program core easily. The modules all reside within the plugins directory. PyFlag will automatically import all modules within that directory and make these available to the user via the menu.</p>
<p>Following is a discussion of each module, and the functionality available through each module.</p>
<div class="section" id="disk-forensics">
<h2><a name="disk-forensics">Disk Forensics</a></h2>
<p>The Flag Disk Forensics Module provides the following capabilities:
- Browsing a disk image and searching, viewing and downloading files within it.
- Calculating a timeline of modified, accessed and created timestamps for all files within an image.
- Calculting file types (file magic) and hashes (MD5sums) and comapring these against the NIST NSRL hash set (if present).
- Browsing/Searching windows registry hives.
- Examining the combined total of all IE History files in the image
- Keyword searching and indexing in the Logical Image (See Index Search below)</p>
<p>These map to the reports which appear in the &quot;Disk Forensics&quot; tab in flag.</p>
</div>
<div class="section" id="scanners-and-virutual-filesystems">
<h2><a name="scanners-and-virutual-filesystems">Scanners and Virutual filesystems</a></h2>
<p>An important concept in Flag is that of scanners. Scanners are code modules (located in the Scanners directory) which are executed on each file in the filesystem as the filesystem is loaded. There are a number of types of scanners currently, including:</p>
<blockquote>
<ul class="simple">
<li>scan file and record file type: This scanner establishes the file type of each file by use of the magic library.</li>
<li>scan file and record file Hash: This scanner calculates the MD5 hash of each file and compares it against the NSRL database.</li>
<li>Scan file for viruses: Each file will be scanned for viruses using ClamAV - the free virus scanner.</li>
<li>Load in IE History files: If the scanner comes across any IE History files, they will be analysed and inserted into the case IE History table.</li>
<li>Load in Windows Registry files: If the scanner comes across any windows registry files, they will be analysed.</li>
<li>Keyword Index files: The index dictionary will be used to index all files as they are seen.</li>
<li>Recurse into gziped files: This scanner creates entries in the virtual filesystem pointing at the decompressed gzip files. This scanner will allow other scanners to operate on the decompressed data of gzip files (e.g. indexing, hash, and virus scanning will be done on the decompressed files).</li>
<li>Recurse into zip files: This scanner creates entries in the virtual filesystem for all files within the zip file. This allows other scanners to scan files within the zip file automatically.</li>
<li>Recurse into Pst Files: This Scanner allows Flag to analyse PST files (Produced by outlook). PST files contain a lot of different information including email messages, attachments, contacts, appointments etc. This scanner will create virtual filesystem entries for each of these cases so that users may navigate the PST file naturally using the filesystem browser. Since this work is done in the scanner, other scanners are now able to operate on the contents of the pst file. For example, virus scanning of email attachments will occur automatically. Keyword searching of email bodies will also occur automatically.</li>
</ul>
</blockquote>
<p>The Scanners architecture allows the creation of virtual file system entries as files are scanned. The virtual filesystem represents a tree like view of information about files as well as files. For example, when Flag encounters a Zip file, Flag will automatically create a virtual directory which, when followed contains the uncomressed files from within the archive. This powerful feature allows the investigator to naturally examine content of zip files as though they were regular directories and files.</p>
<p>The example shown in the following screen shot emphesizes this feature by showing the user navigating into a PST file. The email examined contains a Zip file as an attachment. Flag makes this attachment transparently available through the virtual filesystem as a virtual file. Since this file is a Zip file, Flag will make the content of the zip file appear as a virtual directory. Clicking on the virtual inodes allows the user to directly examine the content of the files transparently.</p>
<p>image:: images/VirtualFileSystem.png</p>
<p>In the above example it can be seen that the Inodes have a special format. For example the above file has the following format <em>D26|P2119876:1|Z1</em>. It is important to understand the formatting of the inode.</p>
<p>Since Flag uses Filesystem drivers to actually read files, the inode description refers to which driver is needed to read each file, while the pipe character (|) represents the output from one driver being fed into the input of another driver. So in our example, the first part &lt;em&gt;D26&lt;/em&gt; represents the DBFS (database filesystem driver) Inode 26 (in our case this image was imported using SleuthKit so it represents inode 26 as denoted by SleuthKit itself). The output of this is then fed into the PST driver (&lt;em&gt;P2119876:1&lt;/em&gt;) with a specific Inode number that means something to it. The output of this driver is then fed into the Zip file driver (&lt;em&gt;Z1&lt;/em&gt;) with an Inode that represents the second file in the Zip archive. Clearly the interpretation of the inode formatting depends on the individual driver. The recursive behaviour allows flag to recursively analyse data streams contained within other data streams to an arbitrary level.</p>
<p>Since the scanners discover more virtual files as the scan process continues, we dubb the sequence of bytes uncovered by the scanners the &lt;b&gt;Logical Image&lt;/b&gt;, as opposed to the &lt;b&gt;Physical Image&lt;/b&gt; which comprises of the physical bitstream of the image itself. The difference between the two concepts becomes evident when one considers a keyword index search for example. A Keyword search over the physical image will not uncover keywords appearing in emails in PST files, or inside compressed files. Whereas a keyword search over the logical drive has access to the entire virtual filesystem's view of the uncomressed files and the virtual email messages within the PST file itself.</p>
<p>This important distinction makes PyFlag an extremely powerful tool for rapid searching for information which may not be immediately accessible.</p>
</div>
<div class="section" id="loading-the-filesystem">
<h2><a name="loading-the-filesystem">Loading the Filesystem</a></h2>
<p>Before using these reports, the filesystem image must be loaded into flag. This is a three stage process:</p>
<ul>
<li><p class="first">Create a new case, as described above</p>
</li>
<li><p class="first">Create an IO Source using the &quot;Load IO Data Source&quot; report in the &quot;LoadData&quot; tab, this is done by selecting an appropriate IO subsystem as described above and filling out the form appropriatedly</p>
<p>Load the filesystem using the &quot;Load Filesystem Image&quot; report in the &quot;LoadData&quot; tab, the form simply asks for the case to load the data into and the IOSource to find the filesystem in.</p>
<p>Note that the list of available scanners is displayed here with the option of disabling some of the scanners (They are all enabled by default). Some of the scanners take a significant amount of CPU time to complete (for example the Zip file scanner). This may prove to be undesirable in certain situations. In these cases the load process may be sped up by disabling some scanners as required.</p>
<p>Note however, that disabling scanners may remove functionality from the DiskForensics module. For example disabling the Zip file scanner will result in zip files not added to the Virtual File System (VFS) which will prevent files within the zip file from being indexed or virus scanned.</p>
</li>
</ul>
<p>Once the image is loaded the reports in the DiskForensics tab can be run.</p>
</div>
</div>
<div class="section" id="unstructured-disk-forensics">
<h1><a name="unstructured-disk-forensics">Unstructured Disk Forensics</a></h1>
<p>Sometimes it is impossible to recover files directly off a hard disk image. This may be due to the disk being corrupted, or the files being deleted, while the filesystem does not support file un-deletion (for example NTFS). In these cases it may be possible to recover some files by looking at the raw disk as a big chunk of binary data, without structure or filesystem, hence the term unstructured forensics.</p>
<p>Most filesystems try to keep files un-fragmented as much as possible. This is usually a performance consideration, but on the balance, files reside in allocated sequential blocks. This property can be exploited for forensically recovering the files. Since most files have a definite file header (sometimes called file &lt;i&gt;magic&lt;/i&gt;), it is possible to search the raw disk for this magic and extract data.</p>
<p>This is the purpose of the &quot;Extract Files&quot; report. To look for possible files on the disks. This is not perfect since sometimes files are overwritten, or fragmentation corrupts them. Often though, this is enough evidence that contraband files were found (e.g. illegal pornography), or that document fragments can be retrieved (Often it is possible to read the text of office documents, despite them being corrupted). The image below illustrates the Unstructured Forensics report.</p>
<p>image:: images/UnstructuredForensics.png</p>
<p>As can be seen, thumbnails are generated on the fly for each suspected file type. The filename given to each extracted file consists of the offset within the image, and the extension based on the file type. (Note that Microsoft office documents all have the .doc extension, because all Microsoft office documents have the same magic).</p>
<p>By clicking on each image, it is possible to download the file, view a hexdump of the file or see strings within the file.</p>
<div class="section" id="text-indexing">
<h2><a name="text-indexing">Text Indexing</a></h2>
<p>When analysing hard disk evidence, it is often useful to do keyword searches. A keyword may be embedded within the body of an executable or within a deleted slack space which is crucial to the course of the investigation.</p>
<p>There are basically two ways for doing a keyword search:</p>
<ol class="arabic">
<li><p class="first">string search:</p>
<p>Searches the entire disk for a particular string that may have been uncovered during the course of the investigation. Typically this string is not known in advance and therefore an index can not be created.</p>
<p>Traditionally this kind of search can be done by using the grep utility, or a similar functionality to find the pattern in the image. This technique is suitable when a limited number of search patterns is required, and reads the entire image as the search is being performed. Sometimes a &quot;strings&quot; file is produced using the strings command in order to reduce the size of the data set searching must be performed over. Performance is limited for this technique since the the user must wait for the grep operation to complete each time a new search term is used.</p>
</li>
<li><p class="first">Index search:</p>
<p>An index is a way of storing offsets of search terms within an index file, for rapidly retrieving later. We index a set of search terms (dubbed a dictionary) within the image. Locating the occurrence of any of the search terms within the image is extremely quick since the offset is already stored in the index. The downside of this technique is that it is impossible to search for a word which is not in the index, after the index has been created, short of re-indexing the file again.</p>
<p>This technique is mostly suitable for searching for a great number of search terms at the same time. (The indexing algorithm used is almost constant time with respect to the number of search terms - i.e. it takes almost as long to index for a dictionary of a single word as the entire English language dictionary). This technique is most suitable for standard forensic work, where a preliminary indexing of the drive can be done in batch mode using the flag shell for example (see flash later).</p>
<p>The indexing reports are found in the &quot;Index Tools&quot; family of reports. Building a dictionary of search terms will be saved in the main flag database, and so will persist for all cases. A classification for each word is used to allow quick searching for words related to specific types of forensic investigation. For example the classification &lt;b&gt;Child Porn&lt;/b&gt;, may be used for words like &quot;sex&quot;,&quot;children&quot; etc, while &lt;b&gt;Hackers&lt;/b&gt; may be used for words like &quot;haxor&quot;, &quot;l33t&quot; etc.</p>
<p>By indexing an image, an IO Source is indexed creating a binary index file in the results directory. This file contains offsets to the specific occurrence of every word in the index within the IO source. Once the index is created, the user is then able to search for words in the index. Note that although a user may type any word as a search term, since an index is used, PyFlag is only able to find words which are in the index - it is not searching for new words. For example, if the index dictionary contains both the words &quot;linux&quot; and &quot;linus&quot;, searching for &quot;lin&quot; will return both matches for linux and linus, but will not return matches for &quot;linen&quot; for example...</p>
<p>If disk space is plentiful, it is recommended to add as many words as possible to the dictionary (since indexing is almost constant time this should not slow the indexing process very much). The author often uses a complete dictionary of the English language (often found in &lt;i&gt;/usr/dict/words&lt;/i&gt;). A simple script is provided under the &quot;indextools&quot; directory to allow merging of the standard words dictionary into PyFlag. Note that this dictionary will often index about 70-90 thousand different words.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="log-analysis">
<h1><a name="log-analysis">Log Analysis</a></h1>
<p>Flags provides a simple yet powerful log analysis capabilities based on the Flag table view (described above). Since servers generate a wide variety of log file formats, it is often difficult to properly parse the log files in a consistant manner. Even the same software package can generate log files in very different formats depending on configurations. (For example Apache can generate an arbitrary log format based on configuration directives).</p>
<p>The result of this is that we need some way of logically telling Flag how to interpret the log file in order to parse it into the database. This template is called a &lt;b&gt;Log Preset&lt;/b&gt; in Flag. A Log Preset simply represents a way of how to extract tabular data (i.e. columns and rows) from the log file so that the data may be stored uniformly in the database. Since different servers produce logs in different formats (depending on configuration), there will usually be different presets for each server.</p>
<p>Once a preset has been created, the same preset may be used in the future to load log files from the same server.</p>
<p>PyFlag uses the concept of log file drivers. A Log File Driver is a specialised bit of code that can read certain types of log files. Since log files come in a variety of formats, certain parsing algorithms work best with certain log types. A preset, therefore, encapsulates the driver used as well as any specific parameters it may require.</p>
<p>Therefore, prior to loading a log file for analysis, we need to create a preset. In order to begin creating a preset we select the &quot;Create Log Preset&quot; Report within the LogAnalysis module. After selecting a sample log file of the required format, we may select the Log File driver. Following are descriptions of the individual options for each Log File driver.</p>
<div class="section" id="the-simple-log-file-driver">
<h2><a name="the-simple-log-file-driver">The Simple Log File Driver</a></h2>
<p>The Simple log file driver splits each line of the log file into columns based on a simple delimiter. If the logfile is simplistic enough, a reasonable approximation may be made. The following steps are taken:</p>
<ul>
<li><p class="first">The user may choose among a number of delimiters. Usually space is common.</p>
</li>
<li><p class="first">Next Flag will read the first several lines from the log file and display them unaltered. This is used for the user to verify that indeed they have the right file selected.</p>
</li>
<li><p class="first">Often a log file will not break on a simple delimiter cleanly, or some of the fields will need to be converted before the database will accept them. Notable for this is the apache common log format which stores dates in the following format: &lt;em&gt;01/Oct/2001:04:21:23&lt;/em&gt;. This format can not be understood by the database, so a prefilter must be used to convert from one format to another.</p>
</li>
<li><p class="first">Prefilters are simple regular expression substitution operators that apply on each line in the log file prior to it being split. (Users may need to click &quot;submit&quot; in order for their choices to be registered.)</p>
</li>
<li><p class="first">PyFlag will now show the same sample lines as before after the prefilter transformation. This makes it easy to examine the effect of the transformation on the log file</p>
</li>
<li><p class="first">A GUI is now drawn to allow the user to name each column and specify its type. Depending on the selected type, a database storage type will be assigned for log entries. This allows the database to store the data in the most appropriate and optimal type. For example if a column is an &quot;IP Address&quot;, it will be stored as an INT in the database, and the whois lookup will be automatically done on it.</p>
<p>Adding an index on a column will make searching on the column much faster. The down side is a slight space requirement for the index. Note that since indexes are always added after the data has been inserted into the database, specifying an index on a column does not slow log importation down very much.</p>
</li>
<li><p class="first">Once the user is happy with their choices, they may click on the final preview checkbox. PyFlag will then create a temporary table and use the preset to insert a few log file lines into it. The results will then be displayed in a table. This final check is required to ensure that the column formats are compatible with the database. For example, if the date format is incompatible with the database, the database will coerce the date value to be 0 (usually 1970). This sort of problem can be easily picked up in this stage.</p>
</li>
<li><p class="first">Now the user can name the preset and save it off. This name will then be used in the future to load new log files from the same server.</p>
</li>
</ul>
<p>Pyflag may then be used to load a log file into a table, and then view the table using the table widget. Power searching may be done on the data as described above.</p>
</div>
<div class="section" id="csv-log-file-driver">
<h2><a name="csv-log-file-driver">CSV Log File Driver</a></h2>
<p>Although at first glance a Comma Delimited file (CVS) seems like it may be processed using a simple delimiter, this is sometimes not the case. The reason is that CSV files often contain the delimiter (oftern comma) within fields. In that case special escape sequences or quoting are used to ensure the embedded commas are not mistaken to be delimiters.</p>
<p>To this end the CSV driver is a reliable way of importing such data, even when the delimiter appears within the field data.</p>
<p>The CSV driver uses its own CVS parsing engine to split each line into columns, and then presents an identical interface as the Simple Log File driver to allow users to name each column and specify its type.</p>
</div>
<div class="section" id="iis-log-file-driver">
<h2><a name="iis-log-file-driver">IIS Log file driver</a></h2>
<p>Microsoft IIS web/ftp server logs in a simple space delimited format. The IIS logfiles are designed to be machine readable by having a comment line at the top of the file with the fields logged and they order. This line allows the automatic assignment of column names and types. This allows the user to bypass the selection GUI and automatically create a preset for the specific file.</p>
<p>No further options are required for this driver. If the IIS log file is well formed, the driver will automatically generate a correct preset and allow the user to verify it in the final preview table.</p>
</div>
</div>
<div class="section" id="network-packet-analysis">
<h1><a name="network-packet-analysis">Network Packet Analysis</a></h1>
<p>The Network capture analysis is based on dissecting the packets using ethereal and loading the results into the database for analysis. Network analysis can be performed in two modes, corresponding to the flag tabs:</p>
<ul>
<li><p class="first">TCPDump Analysis, this involves loading all packet data into the database for close inspection. This level of analysis allows the investigator to do things such as:</p>
<ul class="simple">
<li>View statistics such as which protocols are used and their relative quantities.</li>
<li>Reassemble and view TCP sessions, including replaying HTTP sessions directly to the browser</li>
<li>View full packed breakdowns similarly to ethereal</li>
<li>Protocol specific analysis for several protocols including HTTP and DNS.</li>
</ul>
<p>To load a full packet capture, use the &quot;Load Pcap File&quot; report in the &quot;Load Data&quot; tab. You can then use the reports in the &quot;TCPDumpAnalysis&quot; tab to analyse the data.</p>
</li>
<li><p class="first">Knowledge Base Analysis. Rather than loading all packet data into the database, the knowledge base mode analyses the traffic and makes assertions based on what it sees, eg. &quot;ip 1.1.1.1 is talking to 2.2.2.2&quot; (because we say an ip packet with those src and dst fields) or &quot;ip 1.1.1.1 is listening on TCP port 80&quot; (because we saw a TCP syn,ack from that ip/port). This mode is faster and creates a much smaller database. The knowledge base objects and relationships can be queried and graphed in various ways using the reports in the 'KnowledgeBase' tab in flag. To load the packet capture into flag, use the &quot;Build Knowledge Base&quot; report in the &quot;Load Data&quot; tab.</p>
</li>
</ul>
</div>
<div class="section" id="flash-the-flag-shell">
<h1><a name="flash-the-flag-shell">FLASH: The flag shell.</a></h1>
<p>PyFlag has a great GUI which allows quick navigation of the results of forensic analysis. However, any forensic practitioner knows that forensics is a slow process, on any hardware. With typical hard disk image sizes increasing exponentially, many forensic investigations do take a long time to proceed. Users of PyFlag may have noticed that PyFlag caches the results of analysis, so it only needs to perform the analysis once. Subsequent navigation of reports loads the cached version making the navigation phase very quick. The analysis phase on the other hand does take some time.</p>
<p>One of the strengths of PyFlag is that the User Interface (The UI), is abstracted from the program. In other words how the user interacts with the software can be easily changed without altering the main body of code very much. This opens the door to a variety of different GUI options. So far we have been introduced to the HTML GUI, which is the main web front end, and also currently the most functional for certain tasks.&lt;p&gt;</p>
<p>The command line interface (CLI) has been a central concept in Unix for decades. Although most new users fear the CLI, claiming it is less intuitive and more difficult to use than a GUI, the CLI has stuck around, and is not going anywhere. The reason for that is that CLI is more powerful in certain circumstances, and it allows batching or scripting. PyFlag allows users to use either interface interchangeably, so for those users not comfortable with the CLI, they can still use the GUI.</p>
<div class="section" id="flash-commands">
<h2><a name="flash-commands">Flash commands</a></h2>
<p>Flash can be started from the main PyFlag directory by typing <tt class="literal"><span class="pre">./flash</span></tt>:</p>
<pre class="literal-block">
mic&#64;debian:~/pyflag$ ./flash
Welcome to the Flag shell. Type help for help
Flag Shell: /&gt;help
PyFlag shell allows direct access to the filesystems. Command line expansion is supported.
The following commands are defined, type help command to find out more:
['load', 'execute', 'set', 'help', 'less', 'cd', 'pwd', 'exit', 'ls', 'command', 'cp', 'istat']
Flag Shell: /&gt;help load
load case.iosource: loads the iosource within case into the shell.
</pre>
<ul class="simple">
<li>load:
loads a filesystem into the shell for use with the ls,cp etc commands. The filesystem to load must have previously be loaded by the appropriate LoadData report.</li>
<li>execute:
Allows the user to execute the analysis phase of any report. More on this later.</li>
<li>set:
Sets an environment variable</li>
<li>less:
Views a file from the virtual file system using the less pager</li>
<li>istat:
show information about an inode in the virtual filesystem</li>
</ul>
</div>
<div class="section" id="the-virtual-filesystem">
<h2><a name="the-virtual-filesystem">The Virtual Filesystem</a></h2>
<p>Imagine performing a forensic investigation: You went on site and imaged a hard disk using sgzip to conserve space, knowing that PyFlag can easily work off that. You took the evidence back to the lab and successfully used PyFlag to locate a directory with some interesting word documents. You want to extract those files for evidence, but there are several hundred such documents in the same directory, and mixed between those are other files of different extensions.</p>
<p>The problem here is that it will take too long to use the GUI to extract those files. Because each of these files needs to be navigated to, opened and saved. For those users who use linux for forensic analysis, it would be nice to be able to mount the image on a directory, then simply issue a big copy command and thats it. However linux will not mount an sgzipped file!!!</p>
<p>The flash virtual file system is what is really needed in this case. After the filesystem is loaded into PyFlag (either through the GUI or a script), we can simply load the filesystem into flash (the flag shell) and navigate it as per normal. Consider the following session:</p>
<pre class="literal-block">
mic&#64;debian:~/pyflag$ ./flash
Welcome to the Flag shell. Type help for help
Flag Shell: /&gt;load honey.usr
Set file to read from as /var/tmp/flag/upload/honeypot.hda5.dd.sgz
Loaded Filesystem tag usr in case honey
Flag Shell: /&gt;pwd
Current directory is /
Flag Shell: /&gt;ls -l
d/d 11 lost+found
d/d 30785 doc
d/d 92353 lib
....
Flag Shell: /&gt;cd man/.Ci/
current working directory /man/.Ci/
Flag Shell: /man/.Ci/&gt;cp * /tmp/evidence/
Copied /man/.Ci/ssh-1.2.27 in image to /tmp/evidence/ssh-1.2.27 on host
Copied /man/.Ci/named.tar in image to /tmp/evidence/named.tar on host
....
Flag Shell: /&gt;exit 
Bibi Then - Have a nice day.
</pre>
<p>As can be seen by the previous session, this is the perfect solution for scripting automated tasks. First the virtual filesystem is loaded into flash. Once that happens it is possible to navigate through the filesystem as though it was actually mounted at the root of flash (&quot;/&quot;). We can cd to different directories, and then we can even use shell globing to copy many files at once.</p>
<p>Note the command &lt;i&gt;cp * /tmp/evidence/&lt;/i&gt;. Here we are copying many files by using a wild-card to the temporary directory. The directory &quot;/tmp/evidence/&quot; is located on our host (i.e. not in the image). Note that this will also extract deleted files if possible.</p>
</div>
<div class="section" id="flash-scripts">
<h2><a name="flash-scripts">Flash Scripts</a></h2>
<p>Sometimes forensic investigations are time consuming, much work needs to be done before real evidence is forthcoming. For example the author likes to go through similar steps whenever getting a new hard disk image:</p>
<ol class="arabic simple">
<li>Create an IOSource of a drive</li>
<li>Load the drive's filesystems into PyFlag</li>
<li>Build the MAC time-line for each filesystem</li>
<li>Run an NSRL hash comparison on all the files</li>
<li>Virus scan all the files on the drive looking for known trojans</li>
<li>Extract files by magic, looking for deleted images/movies/documents</li>
<li>Index the drive against the indexing dictionary</li>
</ol>
<p>And then this process must be repeated for every drive found (some jobs have lots of drives!!!). This process is very time consuming, and can take many hours to complete, even on state of the art hardware.</p>
<p>The solution for this problem is to be able to script the whole process, leaving it to run on its own. The analyst then only needs to look at the case once all the time consuming tasks have been done automatically, and add the human element to the task.&lt;p&gt;</p>
<p>All reports in PyFlag are broken down into a number of methods. The two most interesting methods in this context are the analysis method and the display method. The analysis method typically performs time consuming tasks, building a cache of results for future display methods. The display methods, on the other hand, simply format the results for users to navigate through. The result of this design is that analysis methods contain all the time consuming analysis code, which once run, will be cached by PyFlag. Once an analysis method is run for a certain report, the user may issue subsequence display method calls to navigate through the information very quickly.</p>
<p>Flash allows the execution of the analysis methods in a scripted fashion, or from within the shell. This is achieved by the &lt;i&gt;execute&lt;/i&gt; command:</p>
<pre class="literal-block">
Flag Shell: /man/.Ci/&gt;help execute
       This command executes a flag report giving it the arguments given. 
The general format of this command is:
</pre>
<dl>
<dt>::</dt>
<dd>execute Family.ReportName arg1=value arg2=value</dd>
</dl>
<dl>
<dt>::</dt>
<dd>Note that environment values are automatically included into the set of args. So you may use set to set args that are commonly used.</dd>
</dl>
<dl>
<dt>::</dt>
<dd>Note also that command line completion is enabled for this, and so may be used liberally to assist with both the selection of reports and the args needed</dd>
</dl>
<p>In order to figure out what arguements are required for each report, users can use the GUI to perform the analysis and then copy the URL from the browser here.</p>
<p>For example, Loading a filesystem in the browser produces a URL like this:</p>
<pre class="literal-block">
http://127.0.0.1:8000/f?case=blah&amp;iosource=cdrom&amp;report=LoadFS&amp;family=LoadData&amp;fstype=mounted
</pre>
<p>Therefore, in this example, the following command line arguments are required for flash:</p>
<pre class="literal-block">
Flag Shell: /&gt;execute LoadData.LoadFS case=blah fstype=mounted iosource=cdrom
Execution of LoadData.LoadFS successful
</pre>
<p>This process can be written in a script. Scripts can have variables to be interpolated into them after asking the user a question. For example, the &quot;examples/&quot; directory has a flash script for performing an initial analysis of a drive. Scripts are loaded by flash and variables are interpolated, for example:</p>
<pre class="literal-block">
mic&#64;debian:~/pyflag$ ./flash -c examples/load_new_file.flash
Welcome to the Flag shell. Type help for help
Please enter a value for case: honey
Please enter a value for io source: user_partition
Please enter a value for sgziped filename: /var/tmp/flag/upload/honeypot.hda5.dd.sgz
Please enter a value for filesystem type: linux-ext2
....
</pre>
<p>As can be seen flash asks the user some questions, and then launches into performing all the time consuming analysis tasks. Although flash does not support a complete scripting language, this much can be very useful already.</p>
</div>
</div>
</div>
</body>
</html>
